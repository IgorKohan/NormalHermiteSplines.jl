var documenterSearchIndex = {"docs":
[{"location":"Usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"Usage/#D-interpolation-case","page":"Example Usage","title":"1D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function f(x)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"f(x) =\r\n    begincases\r\n       0     1 le x lt 6 \r\n       1     6 le x le 10 \r\n       -x5 + 3     6 le x le 15 \r\n       0     15 le x le 20 \r\n    endcases","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"by values of the function in nodes 1 2 3  20 (case A) and by values of the function and values of its first derivatives in the same nodes (case B). Firstly we'll build a spline using the reproducing kernel RK_H1():","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = quote\r\n    using Random\r\n    using NormalHermiteSplines\r\nend","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the 'scaling parameter' the spline being built with\r\n    ε_estimation = estimate_epsilon(x, RK_H1())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # Build a differentiable spline by values of function in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = prepare(x, RK_H1())\r\n    \r\n    # A value of the 'scaling parameter' the spline was built with.\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # Construct the spline for given 'u' values\r\n    spline = construct(spline, u)\r\n\r\n    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)        # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Construct spline by different function values in nodes and evaluate new spline at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    u2 = 2.0 .* u\r\n    spline = construct(spline, u2)\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    s = x                         # function first derivative nodes\r\n    v = x.*0.0                    # function first derivative values\r\n    for i in 11:14\r\n        v[i] = -0.2\r\n    end\r\n\r\n    # Build a differentiable spline by values of function,\r\n    # and values of its first derivatives in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = interpolate(x, u, s, v, RK_H1())\r\n\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)      # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                  # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"C) ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Now let's interpolate function f(x) using a spline built with reproducing kernel RK_H0:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    # Build a continuous spline by values of function in nodes\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = interpolate(x, u, RK_H0())\r\n\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)        # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1C)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This spline is an infinitely differentiable function everywhere excepting the spline nodes. Its derivative does not exist at spline nodes but we can differentiate the spline at other points. Let's evaluate the spline derivatives at the same evaluation points (which do not coincide with the spline nodes):","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/#D-interpolation-case-2","page":"Example Usage","title":"2D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function phi (xy)  = frac23cos(10x)sin(10y) + frac13sin(10xy) defined on unit square Omega = 01^2.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-cf-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-t-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-32,1.png\" width=\"197\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We built a spline using function phi values sampled on set of 100 pseudo-random nodes uniformly distributed on Omega (case A).","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                        Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using function phi values sampled on set of 100 pseudo-random nodes uniformly distributed on Omega and 80 function phi gradient values defined at nodes located on the border of domain Omega (case B):","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-33,1.png\" width=\"197\"/> ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"here red dots represent the function phi gradient nodes. ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                         Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Following is the code example for case A:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    # generating 100 uniform random nodes\r\n    m = 100\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 101x101 on [0, 1]x[0, 1]\r\n    t = 100\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n\r\n    t1 = t + 1\r\n    n = t1^2\r\n    grid = Matrix{Float64}(undef, 2, n)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    f = Vector{Float64}(undef, n)\r\n    for i = 1:n\r\n        x = grid[1,i]\r\n        y = grid[2,i]\r\n        f[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # Here spline is constructed with RK_H2 kernel,\r\n    # the value of the 'scaling parameter' ε is estimated\r\n    # in the interpolate procedure.\r\n    rk = RK_H2()\r\n    spline = interpolate(nodes, u, rk)\r\n    #\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate(spline, grid)\r\n    # Return the Root Mean Square Error (RMSE) of interpolation\r\n    rmse = sqrt(sum((f .- σ).^2)) / sqrt(length(f))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"   # Return the Maximum Absolute Error (MAE) of interpolation\r\n   mae = maximum(abs.(f .- σ))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Corresponding code example for case B:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    function get_2D_border_nodes(m::Int)\r\n        mat0 = [0.0 0.0; 0.0 1.0; 1.0 0.0; 1.0 1.0]'\r\n        if m < 1\r\n            return mat0\r\n        end\r\n        m1 = m + 1\r\n        p = collect(range(1.0/m1, (1.0 - 1.0/m1); step = 1.0/m1))\r\n        ms = m * 4\r\n        mat = Matrix{Float64}(undef, 2, ms)\r\n        for i = 1:m\r\n            mat[1,i] = 0.0\r\n            mat[2,i] = p[i]\r\n        end\r\n        for i = (m+1):(2*m)\r\n            mat[1,i] = 1.0\r\n            mat[2,i] = p[i-m]\r\n        end\r\n        for i = (2*m+1):(3*m)\r\n            mat[1,i] = p[i-2*m]\r\n            mat[2,i] = 0.0\r\n        end\r\n        for i = (3*m+1):(4*m)\r\n            mat[1,i] = p[i-3*m]\r\n            mat[2,i] = 1.0\r\n        end\r\n        w = hcat(mat0, mat)\r\n        return w\r\n    end\r\n\r\n    # generating 100 uniform random nodes\r\n    m = 100\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    bnodes = get_2D_border_nodes(19)   # 80 border nodes \r\n    bn_1 = size(bnodes, 2)\r\n    d_nodes = Matrix{Float64}(undef, 2, bn_1)\r\n    es = Matrix{Float64}(undef, 2, bn_1)\r\n    du = Vector{Float64}(undef, bn_1)\r\n    grad = [0.0; 0.0]\r\n    for i = 1:bn_1\r\n        x = bnodes[1,i]\r\n        y = bnodes[2,i]\r\n        d_nodes[1,i] = x\r\n        d_nodes[2,i] = y\r\n        grad[1] = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n        grad[2] = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0\r\n        es[1,i] = grad[1]            # no need to normalize 'es' vectors\r\n        es[2,i] = grad[2]\r\n        du[i] = sqrt(grad[1]^2 + grad[2]^2)\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 101x101 on [0, 1]x[0, 1]\r\n    t = 100\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n\r\n    t1 = t + 1\r\n    n = t1^2\r\n    grid = Matrix{Float64}(undef, 2, n)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    f = Vector{Float64}(undef, n)\r\n    for i = 1:n\r\n        x = grid[1,i]\r\n        y = grid[2,i]\r\n        f[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # Here spline is constructed with RK_H2 kernel,\r\n    # the 'scaling parameter' ε is defined explicitly.\r\n    rk = RK_H2(1.0)\r\n    spline = interpolate(nodes, u, d_nodes, es, du, rk)\r\n    #\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate(spline, grid)\r\n    # Return the Root Mean Square Error (RMSE) of interpolation\r\n    rmse = sqrt(sum((f .- σ).^2)) / sqrt(length(f))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"   # Return the Maximum Absolute Error (MAE) of interpolation\r\n   mae = maximum(abs.(f .- σ))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/#Q-and-A","page":"Example Usage","title":"Q & A","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q1. Question: The call","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"spline = interpolate(x, u, RK_H2())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cause the following error: PosDefException: matrix is not positive definite; Cholesky factorization failed. What is a reason of the error and how to resolve it?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A1. Answer: Creating a Bessel potential space reproducing kernel object with omitted scaling parameter ε means that this parameter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too small and corresponding  Gram matrix of the system of linear equations which defines the normal spline coefficients is a very ill-conditioned one and it lost its positive definiteness property because of floating-point rounding errors.  ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"There are two ways to fix it.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We can get the estimated value of the parameter ε by calling get_epsilon function:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"then we can call the interpolate function with a larger value of this parameter:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"larger_ε = 5.0*ε\r\nspline = interpolate(x, u, RK_H2(larger_ε))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We may change the precision of floating point calculations. Namely, it is possible to use Julia standard BigFloat numbers or Double64 - extended precision float type from the package DoubleFloats:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using DoubleFloats\r\n\r\nx = Double64.(x)\r\nu = Double64.(u)\r\nε = Double64(1.0)\r\nspline = interpolate(x, u, RK_H2(ε))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This answer also applies to reproducing kernel object of type RK_H0 or RK_H1.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q2. Question: The following calls","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"spline = interpolate(x, u, RK_H2())\r\nσ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"produce the output which is not quite satisfactoty. Is it possible to improve the quality of interpolation?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A2. Answer: Creating a Bessel potential space reproducing kernel object with omitted scaling parameter ε means that this parameter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too large and it is possible to use a smaller value of ε which can lead to a better quality of interpolation. ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We can get the value of scaling parameter ε by calling get_epsilon function","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and get an estimation of the problem's Gram matrix condition number by calling estimate_cond function as well as an estimation of the number of the significant digits in the interpolation result by calling estimate_accuracy function:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cond = estimate_cond(spline)\r\nsignificant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"In a case when estimated number of the significant digits is bigger than 10 and estimated condition number is not very large, i.e. it is less than 10^12, we may attempt to build a better interpolating spline by calling interpolate function with a smaller value of the scaling parameter:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"e_smaller = ε/2.0 \r\nspline = interpolate(x, u, RK_H2(e_smaller))\r\ncond = estimate_cond(spline)\r\nsignificant_digits = estimate_accuracy(spline)\r\nσ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Taking into account new cond and significant_digits values we decide of making further correction of the scaling parameter.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"For further information, see Selecting a good value of the scaling parameter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author = \"Igor Kohanovsky\"","category":"page"},{"location":"#NormalHermiteSplines.jl-package","page":"Home","title":"NormalHermiteSplines.jl package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multivariate Normal Hermite-Birkhoff Interpolating Splines in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"NormalHermiteSplines.jl package implements the normal splines method for solving following interpolation problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem:   Given points p_i p_i in R^n_i=1^n_1, s_j s_j in R^n_j=1^n_2 and a set of unit vectors e_j e_j in R^n_j=1^n_2 find a function f such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag1\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n  \r\n frac partialf  partiale_j (s_j) =  v_j   quad  j = 1 2 dots n_2  \r\n\r\n n_1 gt 0       n_2 ge 0  \r\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where frac partialf  partiale_j (s_j) = nabla f(s_j) cdot e_j = sum _k=1^n  frac partialf  partialx_k  (s_j) e_jk is a directional derivative of f at the point s_j in the direction of e_j.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We assume that function f is an element of the Bessel potential space H^s_varepsilon (R^n) which is defined as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s = n2 + 12 + r   quad r = 12dots  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon can be considered as a \"scaling parameter\", it allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it can be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Bessel potential space H^s_varepsilon (R^n) is a Reproducing kernel Hilbert space, an element f of that space can be treated as a bounded r-times continuously differentiable function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method consists in finding a solution of system (1) having minimal norm in Hilbert space H^s_varepsilon (R^n)  thus an interpolating normal spline sigma is defined as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag2\r\n   sigma = rm argmin   f ^2  (1) forall f in H^s_varepsilon (R^n)   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method is based on the following functional analysis results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bessel potential space embedding theorem\nThe Riesz representation theorem for Hilbert spaces\nReproducing kernel properties","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using these results it is possible to reduce the task (2) to solving a system of linear equations with symmetric positive definite Gram matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method for one-dimensional function interpolation and linear ordinary differential and integral equations was proposed in [1]. An idea of the multivariate splines in Sobolev space was initially formulated in [7], however it was not well-suited to solving real-world problems. Using that idea the multivariate generalization of the normal splines method was developed for two-dimensional problem of low-range computerized tomography in [2] and applied for solving a mathematical economics problem in [3]. At the same time an interpolation scheme with Matérn kernels was developed in [8], this scheme coincides with interpolating normal splines method. Further results related to  applications of the normal splines method were reported at the seminars and conferences [4,5,6]. ","category":"page"},{"location":"#References:","page":"Home","title":"References:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] V. Gorbunov, The method of normal spline collocation. USSR Comput.Maths.Math.Phys., Vol. 29, No. 1, 1989","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] I. Kohanovsky, Normal Splines in Computing Tomography (Нормальные сплайны в вычислительной томографии). Avtometriya, No.2, 1995","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] V. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] I. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar on Approximation of Multiparametric functions, Max-Planck-Institute for Mathematics in the Sciences, Leipzig, Germany, 2011.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6] V. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, University of West Bohemia, Plzen, Czech Republic, 2014.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[7] A. Imamov,  M. Dzhurabaev, Splines in S.L. Sobolev spaces (Сплайны в пространствах С.Л.Соболева). Deposited manuscript. Dep. UzNIINTI, No 880, 1989.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[8] J. Dix, R. Ogden, An Interpolation Scheme with Radial Basis in Sobolev Spaces H^s(R^n). Rocky Mountain J. Math. Vol. 24, No.4,  1994.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\r\n      \"index.md\",\r\n      \"Public-API.md\",\r\n      \"Usage.md\",\r\n      \"Normal-Splines-Method.md\"\r\n]\r\nDepth = 3","category":"page"},{"location":"Normal-Splines-Method/#The-Normal-Splines-Method","page":"Normal Splines Method","title":"The Normal Splines Method","text":"","category":"section"},{"location":"Normal-Splines-Method/#The-Normal-Splines-Method-2","page":"Normal Splines Method","title":"The Normal Splines Method","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"A problem of reconstruction of multivariate dependency under incomplete data set arises in many areas of research. Often there is a finite set of experimental measurements  tilde u_i_i=1^m and we may treat an unknown function varphi (x) as an element of a Hilbert space H(R^n). Consider the following data model","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag1\r\n(f_i varphi) =  u_i    qquad   tilde  u_i = u_i + epsilon_i  qquad        1 le i le   m","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where f_i are linear continuous functionals, u_i - \"exact value of measurement\", and epsilon_i - random values uniformly distributed in left -delta  delta right. Hence we have a system of constraints","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag2\r\nleft (f_i varphi) - tilde u_i right le delta   qquad 1 le i le  m  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Problem of the function varphi reconstruction is under-determined. We will approximate varphi by constructing an element of minimal norm from the set of the system (2) solutions. Let's introduce a penalty functional J","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"(J varphi) =   varphi _H ^2  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and find a function varphi in the Hilbert space H to minimize J subject to (2) (here  cdot _H denotes the H norm). Solution of this problem is a generalized spline of Atteia-Laurent [1]. We name it a normal spline following to the V. Gorbunov work [2] where the normal spline-collocation method for linear ordinary differential and integral equations was developed.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The normal spline method consists of a Hilbert norm minimization on the set of a collocation system solutions. In contrast to the classical collocation methods the basis system here is not given a priory, instead it is constructed in accordance with the chosen Hilbert space norm. The base functions are canonical images of the continuous linear functionals presented as inner product in the Hilbert space. Such functional presentation can be found if the Hilbert space H is a reproducing kernel Hilbert space and the corresponding reproducing kernel is known. In order to construct a reproducing kernel useful for a case of one-dimensional problems treated in [2] it was sufficient to suppose the Hilbert space H is a classical Sobolev space with integer order. Multivariate generalization of the normal spline method described in this blog was done ([6] — [10]) with usage of the Bessel potential spaces [3].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Essentially the normal spline method  is based on classical functional analysis results: the Sobolev and Bessel potential space embedding theorems [4], the F.Riesz representation theorem [5] and Reproducing kernel properties.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Here and further we assume that f_i are linearly independent functionals therefore the set of the system (2) solutions is not empty, convex and closed one. It is known that every closed convex set in a Hilbert space has a unique element of minimal norm [1, 5] - here it is a uniform smoothing normal spline:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag3\r\n      sigma = mathoprm argminnolimits lbrace  varphi  ^2_H  (2) rbrace  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In general a normal spline can be treated as a projection of an element of a Hilbert space to a closed convex set in that Hilbert space. Thereby the problem (3) always has the unique solution.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In accordance with Riesz representation theorem [5] every linear continuous functional f_i on a Hilbert space H can be represented as inner product of some element h_i in H and varphi in H, for any varphi in H :","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"      (f_i varphi) = langle h_i  varphi rangle_H   qquad  forall varphi in H   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where langle cdot  cdot rangle_H - inner product in H. Then (2) can be written in form:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag4\r\n     langle h_i  varphi rangle_H - tilde u_i  le delta       qquad 1 le i le m   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and problem (2) is reduced to:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag5\r\n      sigma = mathoprm argminnolimits lbrace langle varphi  varphi rangle_H  (4) rbrace  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In accordance with extremum conditions for the problem (5) its solution can be presented in form [1]:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    sigma =  sum _j=1 ^m (mu _j - mu _j+m) h_j   quad  quad mu _j  le 0  quad mu _j+m le 0  quad 1le j le m ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It allows to reduce the initial problem (5) of constructing a uniform smoothing normal spline to solving a finite-dimensional quadratic programming problem:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag6\r\nbeginaligned\r\n      sigma = mathoprm argmin Biglbrace sum _i=1 ^m sum _j=1 ^m   (mu _i - mu _i+m) (mu _j - mu _j+m) g_ij  (10) (11) Bigrbrace  \r\n    Big sum _j=1 ^m g_ij (mu _j - mu _j+m) - tilde u_i Big  le  delta      qquad 1 le i le m   \r\n   mu _j  le 0  quad mu _j+m le 0  quad 1le j le m  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here g_ij=langle h_i  h_j rangle_H - coefficients of the symmetric Gram matix of the set of the elements h_i h_i in H. Notice that elements h_i (images of functionals f_i) are linearly independent therefore the Gram matrix is a positive definite one.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It was shown [13] that it is not necessary to formulate the problem (6) in its explicit form. A special version of algorithm for solving this simple quadratic programming problem will be described in the next sections.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Results related to multidimensional normal spline method and its applications were published in works [6, 10] and presented at conferences [8, 9, 11, 12].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] P.-J. Laurent, Approximation et optimization, Paris, 1972.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] V. Gorbunov, The method of normal spline collocation. USSR Comput.Maths.Math.Phys., Vol. 29, No. 1, 1989","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] N. Aronszajn, K. Smith, Theory of bessel potentials I, Ann.Inst.Fourier, 11, 1961. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[4] S. Sobolev, Some applications of functional analysis in mathematical physics, AMS, 2008.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[5] A. Balakrishnan, Applied Functional Analysis, New York, Springer-Verlag, 1976.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[6] I. Kohanovsky, Normal Splines in Computing Tomography (in Russian). Avtometriya, No.2, 1995","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[7] I. Kohanovsky, Data approximation using multidimensional normal splines, Unpublished manuscript, 1996.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[8] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[9] I. Kohanovsky, Normal splines in fractional order Sobolev spaces and some of its applications, The Third Siberian Congress on Applied and Industrial mathematics  (INPRIM-98), Novosibirsk, 1998.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[10] V. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[11] I. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar Leipzig on Approximation of Multiparametric functions, Max-Planck-Institute for Mathematics in the Sciences, Leipzig, Germany, 2011.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[12] V. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, University of West Bohemia, Plzen, Czech Republic, 2014.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[13] V. Gorbunov, Extremum Problems of Measurements Data Processing. Ilim Publishers, Frunze, 1990 (in Russian).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#The-Riesz-representation-of-functionals-and-a-reproducing-kernel-Hilbert-space","page":"Normal Splines Method","title":"The Riesz representation of functionals and a reproducing kernel Hilbert space","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In this section we discuss a way of constructing a Riesz representer of the continuous linear functional f on a Hilbert space H, assuming the space H is a reproducing kernel Hilbert space. Let's recall the Riesz representation theorem and the reproducing kernel Hilbert space definition.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Riesz representation theorem ([1]): If f is a linear continuous functional on a Hilbert space H then there exists some h in H such that for every varphi in H we have","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"     (f varphi) = langle varphi  h rangle_H","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Reproducing Kernel Hilbert space definition ([2]): A Hilbert space H(R^n) is called a reproducing kernel Hilbert space (RKHS) if there is a reproducing kernel function K(eta x) of eta and x in R^n such that:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"For any x in R^n the function K(eta x) belongs to H(R^n) as a function of the eta.\nThe reproducing property: for any x in R^n and any varphi in H(R^n), the following equality is valid:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"qquad qquad qquad qquad qquad qquad qquad qquad  qquad  varphi (x) = langle varphi(eta)  K(eta  x) rangle_H","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Inner product here applies to functions of eta. It is known, if a reproducing kernel exists it is unique and it is symmetric with respect to the eta and x ([2]): K(eta  x) = K(x eta).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let K(eta x) is a reproducing kernel of the Hilbert space H(R^n), then we can find the Riesz representer h of the functional f. Namely:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"      h (x) = (f K (cdot x))  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Indeed, by reproducing property:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"      h (x) = langle h  K(cdot  x) rangle_H","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"but since the h is a Riesz representer of the f:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"      langle h  K(cdot  x) rangle_H = (f  K(cdot  x) ) ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here K(eta x) in H as a function of the eta.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let's we have a set of the continuous linear functionals f_i on Hilbert space H and the corresponding set of their Riesz representers h_i. Then coefficients g_ij of the Gram matrix of elements h_i can be found as follows:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" qquad qquad  g_ij = langle h_i  h_j rangle_H = (f_i  h_j) =  bigl(f_i  ( f_j  K ) bigr)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] A. Balakrishnan. Applied Functional Analysis. // New York: Springer-Verlag, 1976.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] N. Aronszajn, Theory of reproducing kernels, Transactions of the AMS, Vol. 68, No. 3, 1950.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Reproducing-Kernel-of-Bessel-potential-space","page":"Normal Splines Method","title":"Reproducing Kernel of Bessel potential space","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The standard definition of Bessel potential space H^s can be found in ([1], [2], [6], [11], [12]). Here the normal splines will be constructed in the Bessel potential space H^s_varepsilon defined as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s gt fracn2 ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon introduced here may be considered as a \"scaling parameter\". It allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it may be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Theoretical properties of spaces H^s_varepsilon at varepsilon gt 0 are identical — they are Hilbert spaces with inner product","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"langle varphi  psi rangle _H^s_varepsilon =\r\nint ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal F varphi  overlinemathcal F psi    d xi","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and  norm","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" varphi _ H^s_varepsilon = left( int ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal  F varphi  ^2   d xi  \r\n right)^12  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It is easy to see that all  varphi _H^s_varepsilon norms are equivalent. It means that space H^s_varepsilon (R^n) is equivalent to H^s (R^n) =  H^s_1 (R^n).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let's describe the Hölder spaces C_b^t(R^n) t gt 0 ([9], [2]).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Definition 1. We denote the space","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"   S(R^n) = left f  f in C^infty (R^n)   sup_x in R^n  x^alpha D^beta f(x)   lt infty  forall alpha beta in mathbbN^n  right","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"as Schwartz space (or space of complex-valued rapidly decreasing infinitely differentiable functions defined on R^n) ([6], [7]).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Below is a definition of Hölder space C^t_b(R^n) [9]:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Definition 2. If 0 lt t = t + t t is non-negative integer, 0 lt t lt 1, then C^t_b(R^n) denotes the completion of S(R^n) in the norm","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n   C^t_b (R^n) = left f  f in C^t_b (R^n)    f  _C^t_b  lt infty right  \r\n\r\n   f  _C^t_b =  f  _C_b^t  + \r\n\r\nsum _alpha  = t sup _x ne y frac  D^alpha  f(x)  - D^alpha  f(y)     x - y ^t   \r\n\r\n   f  _C_b^t = sup _x in R^n  D^alpha f(x)   forall alpha   alpha  le t\r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Space C^t_b (R^n) consists of all functions having bounded continuous derivatives up to order t. It is easy to see that C_b^t(R^n) is Banach space [9].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Connection of Bessel potential spaces H^s(R^n) with the spaces C_b^t(R^n) is expressed in Embedding theorem ([9], [2]).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Embedding Theorem: If s = n2+t, where t non-integer, t gt 0, then space H^s(R^n) is continuously embedded in C_b^t(R^n).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Particularly from this theorem follows that if f in H^n2 + 12_varepsilon (R^n), corrected if necessary on a set of Lebesgue measure zero, then it is uniformly continuous and bounded. Further if f in H^n2 + 12 + r_varepsilon (R^n), r — integer non-negative number, then it can be treated as f in C^r (R^n), where C^r (R^n) is a class of functions with r continuous derivatives.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It can be shown ([3], [11], [8], [4], [5]) that function ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  V_s ( eta  x varepsilon ) = c_V (nsvarepsilon) (varepsilon eta - x  )^s - fracn2\r\n\r\n          K_s - fracn2 (varepsilon eta - x  )      \r\n\r\n  c_V (nsvarepsilon) = fracvarepsilon ^n-2s  2^s-1 (2 pi )^n2 Gamma (s)   eta in R^n   x in R^n  varepsilon gt 0   s gt fracn2\r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"is a reproducing kernel of H^s_varepsilon (R^n) space. Here K_gamma is modified Bessel function of the second kind [10]. The exact value of c_V (nsvarepsilon) is not important here and will be set to sqrtfrac2pi for ease of further calculations. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"This reproducing kernel is known as Matérn kernel [4,13].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The kernel K_gamma becomes especially simple when gamma  is half-integer. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"\r\n gamma =  r  + frac12   (r = 0 1 dots )","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In this case it is expressed via elementary functions (see [10]):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\nK_r+12(t) =\r\nsqrtfracpi 2t t^r+1 left (\r\n- frac1t fracddt right )^r+1 exp (-t)  \r\n\r\nK_r+12(t) =\r\nsqrtfracpi 2t exp (-t) sum_k=0^r\r\nfrac(r+k)k (r-k) (2t)^k  \r\n  (r = 0 1 dots )   \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let s_r =  r + fracn2 + frac12   r = 0 1 dots, then H^s_r_varepsilon(R^n) is continuously embedded in C_b^r(R^n) and its reproducing kernel with accuracy to constant multiplier can be presented as follows","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\nV_r + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x ) \r\nsum_k=0^r frac(r+k)2^k k (r-k) (varepsilon eta - x )^r-k  \r\n\r\n  (r = 0 1 dots )   \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In particular we have:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n V_fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )  \r\n\r\n V_1 + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )\r\n(1 + varepsilon eta - x )  \r\n\r\n V_2 + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )\r\n(3 + 3varepsilon eta - x  + varepsilon ^2 eta - x  ^2 )  \r\n\r\n V_3 + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )\r\n(15 + 15varepsilon eta - x  + 6varepsilon ^2 eta - x  ^2  + varepsilon ^3 eta - x  ^3 )  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] D. Adams, L. Hedberg, Function spaces and potential theory. Berlin, Springer, 1996.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] M. Agranovich, Sobolev Spaces, Their Generalizations and Elliptic Problems in Smooth and Lipschitz Domains, Springer, Switzerland, 2015.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] N. Aronszajn, K. Smith, Theory of bessel potentials I, Ann.Inst.Fourier, 11, 1961.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[4] G. Fasshauer, Green’s Functions: Taking Another Look at Kernel Approximation, Radial Basis Functions, and Splines. In: Neamtu M., Schumaker L. (eds) Approximation Theory XIII: San Antonio 2010. Springer Proceedings in Mathematics, vol 13. Springer, New York, 2012.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[5] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[6] S. Nikol'skiĭ, Approximation of functions of several variables and imbedding theorems, Grundl. Math. Wissensch., 205, Springer-Verlag, New York, 1975.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[7] M. Reed, B. Simon, Methods of Modern Mathematical Physics, I: Functional Analysis, Academic Press, 1972.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[8] R. Schaback, Kernel-based Meshless Methods, Lecture Notes, Goettingen, 2011.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[9] H. Triebel, Interpolation. Function Spaces. Differential Operators, North-Holland, Amsterdam, 1978.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[10] G. Watson, A Treatise on the Theory of Bessel Functions ( 2nd.ed.), Cambridge University Press, 1966.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[11] H. Wendland, Scattered Data Approximation. Cambridge University Press, 2005.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[12] J. Lions, E. Magenes, Problemes Aux Limites Non-Homogenes et Applications Vol. 1, Dunod, Paris, 1968.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[13] G. Fasshauer, M. McCourt, Kernel-Based Approximation Methods Using Matlab, World Scientific, Singapore, 2015.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Hermite-Birkhoff-Interpolation-of-Scattered-Data","page":"Normal Splines Method","title":"Hermite-Birkhoff Interpolation of Scattered Data","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Consider the following interpolation problem:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Problem: Given points p_i p_i in R^n_i=1^n_1, s_j s_j in R^n_j=1^n_2 and a set of unit vectors e_j e_j in R^n_j=1^n_2 find a function f such that","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag1\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n  \r\n frac partialf  partiale_j (s_j) =  v_j     j = 1 2 dots n_2  \r\n\r\n n_1 gt 0       n_2 ge 0  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where frac partialf  partiale_j (s_j) = nabla f(s_j) cdot e_j = sum _k=1^n  frac partialf  partialx_k  (s_j) e_jk is a directional derivative of f at the point s_j in the direction of e_j.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We assume that function f is an element of the Bessel potential space H^s_varepsilon (R^n) which is defined as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi(xi) in L_2 (R^n) right    \r\n  varepsilon gt 0   s = n2 + 12 + r     r = 12dots  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon can be considered as a \"scaling parameter\", it allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it can be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Theoretical properties of spaces H^s_varepsilon at varepsilon gt 0 are identical — they are Hilbert spaces with inner product","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"langle varphi  psi rangle =\r\nint ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal F varphi(xi)  overlinemathcal F psi(xi)    d xi","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and  norm","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" varphi  = left( int ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal  mathcal F varphi(xi)  ^2   d xi  \r\n right)^12  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It is easy to see that all these norms are equivalent. It means that space H^s_varepsilon (R^n) is equivalent to H^s (R^n) =  H^s_1 (R^n).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Obviously,  varphi _ H^s_varepsilon le  varphi _ H^t_varepsilon if s  t, so that the space with larger index is continuously embedded in the space with smaller index. The space H^0_varepsilon (R^n) coincides with L_2 (R^n) in view of Parseval’s identity","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" int mathcal  mathcal F varphi  ^2   d xi  = int mathcal varphi^2   dx   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and the norms on these spaces coincide. Therefore, all spaces H^s_varepsilon (R^n) with nonnegative s consist of usual square integrable (i.e., having integrable square of absolute value) functions [3]. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It can be shown that for any positive integer m the space H^m_varepsilon (R^n) consists of all square integrable functions whose derivatives in the sense of distributions up to order m are square integrable [3]. The norm on H^m_varepsilon (R^n) can be defined by","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" varphi  = left( int Big  varepsilon^2  varphi (x) ^2  + sum_alpha = m fracmalpha D^alpha varphi (x) ^2 Big \r\n   d x  \r\n right)^12  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here alpha = (alpha_1 dots alpha_n ) is multi-index with nonnegative integral entries,  alpha  = alpha_1 + dots + alpha_n,  alpha  = alpha_1  dots alpha_n  and D^alpha varphi (x) = frac partial^alphavarphi  partialx_1^alpha_1 dots x_n^alpha_n. The norms  varphi  and  varphi  are equivalent and space H^m_varepsilon (R^n) coincides with Sobolev space. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Hilbert space H^s_varepsilon (R^n) is continuously embedded in Hölder space C_b^r(R^n) ([3],[17],[20]) of functions continuous and bounded with their first r derivatives, it means function f can be treated as an element of function class C^r(R^n) of functions continuous with their first r derivatives. Therefore functionals F_i and F_j","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n   F_i(varphi) = varphi (p_i)     F_j(varphi) = frac partialvarphi  partiale_j (s_j)     forall varphi in H^s_varepsilon (R^n)  \r\n   quad\r\n   p_i  s_j in R^n  \r\n   \r\n   i = 1 2 dots n_1       j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"are linear continuous functionals in H^s_varepsilon.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We also assume that all points p_i are different and in a case when among points s_j there are coincident ones, we stipulate that the corresponding unit vectors defining the directions of the directional derivatives at such points are linearly independent. Note that some points p_i may coincide with some s_j. Under these restrictions all functionals F_i  F_j are linearly independent.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In accordance with Riesz representation theorem [1] these linear continuous functionals can be represented in the form of inner product of some elements h_i h_j in H^s_varepsilon and varphi in H^s_varepsilon, for any varphi in H^s_varepsilon:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n F_i(varphi) = langle h_i  varphi rangle    quad  F_j(varphi) = langle h_j  varphi rangle    quad  forall varphi in H^s_varepsilon  \r\n  i = 1 2 dots n_1      j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Elements h_i and h_j are continuously differentiable functions. Thereby the original system of constraints (1) can be written in form:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag2\r\nbeginaligned\r\n f(p_i) = F_i(f) = langle h_i  f rangle  = u_i  \r\n\r\n frac partialf  partiale_j (s_j) = F_j(f) = langle h_j  f rangle = v_j    \r\n \r\n   h_i  h_j  f in H^s_varepsilon  \r\n quad\r\n  i = 1 2 dots n_1      j = 1 2 dots n_2  \r\n endaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here all functions h_i and h_j are linear independent and system of constrains (2) defines a nonempty convex and closed set (as an intersection of hyper-planes) in the Hilbert space H^s_varepsilon.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Problem of reconstruction of function f satisfying system of constraints (2) is undetermined. We reformulate it as a problem of finding solution of this system of constraints that has minimal norm:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag3\r\n   sigma = rm argmin   f - z ^2  (2) z in H^s_varepsilon  forall f in H^s_varepsilon   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where z in H^s_varepsilon is a \"prototype\" function. Solution of this problem exists and it is unique ([6], [16]) as a projection of element z on the nonempty convex closed set in Hilbert space H^s_varepsilon. Element sigma is an interpolating normal spline.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In accordance with generalized Lagrange method ([13], [16]) solution of the problem (3) can be presented as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag4\r\nsigma =  z + sum _i=1^n_1 mu_i  h_i  + sum _j=1^n_2 mu_j  h_j   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where coefficients mu_i and mu_j are defined by system of linear equations","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\ntag5\r\n     sum _l=1^n_1 g_il mu_l + sum _j=1^n_2 g_ij mu_j   =  u_i - langle h_i  z rangle   quad 1 le i le n_1   \r\n    \r\n     sum _i=1^n_1 g_ij mu_i + sum _m=1^n_2 g_jm mu_m =  v_j - langle h_j  z rangle    quad 1 le j le n_2  \r\nendaligned    ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Matrix of system (5) is the positive definite symmetric Gram matrix of the set of linearly independent elements  h_i h_j and coefficients g_il g_ij g_jm are defined as follows:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag6\r\n   g_il = langle h_i  h_l rangle     g_ij = langle h_i  h_j rangle      g_jm = langle h_j  h_m rangle  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Space H^s_varepsilon (R^n) is a reproducing kernel Hilbert space ([5],[18],[19],[20]). We denote its reproducing kernel as V(eta xi).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Recall the definition of the reproducing kernel ([4], [7]). The reproducing kernel of space H^s_varepsilon is a such function V(eta xi) that","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"for every xi in R^n,  V(eta xi) as function of eta belongs to H^s_varepsilon\nfor every xi in R^n and every function varphi in H^s_varepsilon","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag7\r\nvarphi(xi) = langle V(eta xi)  varphi(eta) rangle","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Reproducing kernel is a symmetric function:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"V(eta xi) = V(xi eta)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"also in the considered case (s = n2 + 12 + r  r ge 1) it is a continuously differentiable function. Differentiating the identity (7) allows to get the identities for derivatives:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag8\r\nfrac partial varphi(xi)partial xi_k = left langle fracpartial V(cdot xi) partial xi_k varphi right rangle","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"which holds for any varphi in H^s_varepsilon and xi in R^n, it means that function fracpartial V(cdot  xi) partialxi_k represents a point-wise functional defined as value of function frac partial varphi (cdot) partialxi_k at the point xi.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Now it is possible to express functions h_i and h_j via the reproducing kernel V. Comparing (2) with (7) and (8) we receive:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag9\r\nbeginaligned\r\n  h_i (eta) =  V(eta p_i)    qquad qquad qquad qquad qquad   i = 1 2 dots n_1    \r\n  h_j (eta) =  fracpartial V(eta s_j)partial e_j =  sum_k=1^n  frac partial V(eta s_j) partialxi_k e_jk    quad  j = 1 2 dots n_2    \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The coefficients (6) of the Gram matrix can be presented as ([7], [8], [10]):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag10\r\nbeginaligned\r\n    g_il = langle h_i  h_l rangle = langle V(cdot p_i)  V(cdot p_l) rangle = V(p_i p_l)  \r\n   \r\n     g_ij = langle h_i  h_j rangle = left langle V(cdot p_i) fracpartial V(cdot s_j)partial e_j right rangle =  fracpartial V(p_i s_j)partial e_j =\r\n    \r\n     qquad qquad qquad =  sum_k=1^n  frac partial V(p_i s_j) partialxi_k e_jk   \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"With the help of (7) and (10), we can also calculate g_jm ([8], [10]):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag11\r\nbeginaligned\r\n g_jm = langle h_j  h_m rangle   =  left langle fracpartial V(cdot s_j)partial e_j fracpartial V(cdot s_m)partial e_m right rangle   =  frac partial^2 V(s_j s_m) partial e_j partial e_m =\r\n \r\n   =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Further","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag12\r\nbeginaligned\r\n   langle h_i  z rangle  =  langle V(cdot p_i)  z rangle = z(p_i)   \r\n  \r\n   langle h_j  z rangle  = fracpartial z(s_j)partial e_j = sum_k=1^n  frac partial z(s_j) partialx_k e_jk  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Here normal hermite splines will be constructed in Bessel potential spaces H^s_1_varepsilon (R^n)   s_1 = n2 + 32 and H^s_2_varepsilon (R^n)   s_2 = n2 + 52. Elements of space H^s_1 can be treated as  continuously differentiable functions and elements of space H^s_2 can be treated as twice continuously differentiable functions. Note, the spline is infinitely differentiable everywhere in R^n excepting the nodes p_i and s_j.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Reproducing kernel of Bessel potential space was presented in [5] and its simplified form was given in [14], [18], [19], [20]. For space H^s_varepsilon (R^n)  s = n2 + 12 + r  r ge 0 it can be written as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" V(eta  xi) = exp (-varepsilon eta - xi) \r\n     sum_k=0^r frac(r+k)2^k k (r-k) (varepsilon eta - xi)^r-k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"(a constant multiplier is omitted here.)","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"This reproducing kernel is known as the Matérn kernel [23].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Therefore for space H^s_1_varepsilon (R^n) with accuracy to constant multiplier we get:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag13\r\nV(eta xi) =  exp (-varepsilon eta - xi)\r\n             (1 + varepsilon eta - xi)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and for space H^s_2_varepsilon (R^n):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag14\r\nV(eta xi) =  exp (-varepsilon eta - xi)\r\n             (3 + 3varepsilon eta - xi + varepsilon ^2 eta - xi ^2 )  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let's write down expressions of h_i h_j g_il g_ij g_jm for space H^s_1_varepsilon (R^n):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag15\r\nbeginaligned\r\n h_i (eta) =  exp (-varepsilon eta - p_i ) (1 + varepsilon eta - p_i)   qquad  quad   i = 1 2 dots n_1   \r\n h_j (eta) = varepsilon^2 exp (-varepsilon  eta - s_j  ) sum _k=1^n (eta_k - s_jk) e_jk   quad  j = 1 2 dots n_2   \r\n g_il= exp (-varepsilon  p_i - p_l  )(1 + varepsilon  p_i - p_l  )      quad     i = 1 2 dots n_1     l = 1 2 dots n_1   \r\n g_ij = varepsilon^2 exp (-varepsilon p_i - s_j  ) sum _k=1^n (p_ik - s_jk) e_jk      i = 1 2 dots n_1     j = 1 2 dots n_2  \r\n\r\n g_jm =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr\r\n\r\n quad qquad j ne m   quad j = 1 2 dots n_2     m = 1 2 dots n_2  \r\n\r\n textwhere\r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_r = varepsilon^2 exp (-varepsilon  s_j - s_m ) left (1 - varepsilon frac (s_jr - s_mr)^2 s_j - s_m  right)  \r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k = -varepsilon^3 exp (-varepsilon  s_j - s_m ) frac (s_jr - s_mr)(s_jk - s_mk) s_j - s_m     quad r ne k  \r\n\r\n g_jj = varepsilon^2 sum _r=1^n  (e_jr)^2  = varepsilon^2    quad j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and for space H^s_2_varepsilon (R^n):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag16\r\nbeginaligned\r\n h_i (eta) =  exp (-varepsilon eta - p_i ) (3 + 3 varepsilon eta - p_i  +  varepsilon^2  eta - p_i ^2) )\r\n   qquad quad i = 1 2 dots n_1   \r\n h_j (eta) =varepsilon^2 exp (-varepsilon eta - s_j  ) (1 + varepsilon eta - s_j ) sum _k=1^n (eta_k - s_jk) e_jk   quad  j = 1 2 dots n_2   \r\n g_il= exp (-varepsilon p_i - p_l ) (3 + 3 varepsilon p_i - p_l  +  varepsilon^2  p_i - p_l ^2) )  \r\n\r\n qquad qquad qquad qquad qquad qquad qquad i = 1 2 dots n_1     l = 1 2 dots n_1   \r\n g_ij = varepsilon^2 exp (-varepsilon p_i - s_j  ) (1 + varepsilon p_i - s_j ) sum _k=1^n (p_ik - s_jk) e_jk   \r\n\r\n qquad qquad qquad qquad qquad qquad qquad  i = 1 2 dots n_1     j = 1 2 dots n_2  \r\n\r\n g_jm =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr\r\n\r\n quad qquad j ne m   quad j = 1 2 dots n_2     m = 1 2 dots n_2  \r\n\r\n textwhere\r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_r = varepsilon^2 exp (-varepsilon  s_j - s_m ) (1 + varepsilon  s_j - s_m  - varepsilon^2 (s_jr - s_mr)^2)  \r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k = -varepsilon^4 exp (-varepsilon  s_j - s_m ) (s_jr - s_mr)(s_jk - s_mk)    quad r ne k  \r\n\r\n g_jj = varepsilon^2 sum _r=1^n  (e_jr)^2  = varepsilon^2    quad j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In a case when there is no information of function f derivatives the Problem (1) is reducing to the simplest interpolation problem:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Problem: Given points p_i p_i in R^n_i=1^n_1 find a function f such that","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag17\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n\r\n n_1 gt 0  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We assume that f is a bounded continuous function. It can be treated as an element of Bessel potential space H_varepsilon^s_0 (R^n)   s_0 =  n2 + 12, this space is continuously embedded in Hölder space C_b(R^n) of continuous and bounded functions.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Reproducing kernel of Bessel potential space H_varepsilon^s_0(R^n) can be written as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"V(eta  xi) = exp (-varepsilon eta - xi)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"(with accuracy to a constant multipliler), and expressions for h_i g_il are defined by:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag18\r\nbeginaligned\r\n h_i (eta) = exp (-varepsilon eta - p_i )   quad  i = 1 2 dots n_1  \r\n \r\n g_il = exp (-varepsilon  p_i - p_l  ))  \r\n  quad\r\ni = 1 2 dots n_1     l = 1 2 dots n_1  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"When value of the parameter varepsilon is small this normal spline is similar to multivariate generalization of the one dimensional linear spline.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We now consider the choice of value for parameter varepsilon. Approximating properties of the normal spline are getting better with smaller value of varepsilon, and if the value of this parameter is small enough the normal spline become similar to Duchon's D^m -spline [12]. However with decreasing value of varepsilon the condition number of the corresponding problem Gram matrix is increasing and the problem becomes numerically unstable. Therefore, when choosing the value of parameter varepsilon, a compromise is needed. In practice, it is necessary to choose such value of the varepsilon that condition number of Gram matrix is small enough. Numerical procedures of the matrix condition number estimation are well known.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"As well, it is useful to preprocess the source data of the problem by transforming the domain where interpolation nodes are located into the unit hypercube.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The normal splines method for one-dimensional function interpolation and linear ordinary differential and integral equations was proposed in [8] and [9] and developed in [10]. An idea of the multivariate splines in Sobolev space was initially formulated in [25], however it was not well-suited to solving real-world problems. Using that idea the multivariate generalization of the normal splines method was developed for two-dimensional problem of low-range computerized tomography in [15] and applied for solving a mathematical economics problem in [11]. At the same time an interpolation scheme with Matérn kernels was developed in [26], this scheme coincides with interpolating normal splines method. Further results related to  applications of the normal splines method were reported at the seminars and conferences [14,21,22]. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1]  R. Adams, J. Fournier, Sobolev Spaces. Pure and Applied Mathematics. (2nd ed.). Boston, MA: Academic Press, 2003.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] D. Adams, L. Hedberg, Function spaces and potential theory. Berlin, Springer, 1996.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] M. Agranovich, Sobolev Spaces, Their Generalizations and Elliptic Problems in Smooth and Lipschitz Domains, Springer, Switzerland, 2015.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[4] N. Aronszajn, Theory of reproducing kernels, Tranzactions of the AMS, Vol. 68, No. 3, 1950.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[5] N. Aronszajn, K.T. Smith, Theory of bessel potentials I, Ann.Inst.Fourier, Vol. 11, 1961.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[6] A. Balakrishnan, Applied Functional Analysis, New York, Springer-Verlag, 1976.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[7] A. Bezhaev, V. Vasilenko, Variational Theory of Splines, Springer US, 2001.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[8] V. Gorbunov, The method of normal spline collocation, USSR Computational Mathematics and Mathematical Physics, Vol. 29, No. 1, 1989.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[9] V. Gorbunov, Extremum Problems of Measurements Data Processing, Ilim, 1990 (in Russian).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[10] V. Gorbunov, V. Petrishchev, Improvement of the normal spline collocation method for linear differential equations, Comput. Math. Math. Phys., Vol. 43, No. 8, 2003.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[11] V. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[12] J. Duchon, Splines minimizing rotation-invariant semi-norms in Sobolev spaces, Lect. Notes in Math., Springer, Berlin, Vol. 571, 1977.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[13] A. Ioffe, V. Tikhomirov, Theory of extremal problems, North-Holland, Amsterdam, 1979.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[14] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[15] I. Kohanovsky, Normal Splines in Computing Tomography (Нормальные сплайны в вычислительной томографии). Avtometriya, No.2, 1995","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[16] P.-J. Laurent, Approximation et optimization, Paris, 1972.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[17] H. Triebel, Interpolation. Function Spaces. Differential Operators. North-Holland, Amsterdam, 1978.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[18] R. Schaback, Kernel-based Meshless Methods, Lecture Notes, Goettingen, 2011.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[19] H. Wendland, Scattered Data Approximation. Cambridge University Press, 2005.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[20] Reproducing Kernel of Bessel potential space.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[21] V. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, 2014","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[22] I. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar Leipzig on Approximation of Multiparametric functions, 2011","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[23] G. Fasshauer, M. McCourt, Kernel-Based Approximation Methods Using Matlab, World Scientific, Singapore, 2015.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[24] C. Chen, Y. Hon, and R. Schaback, Scientific computing with radial basis functions. Department of Mathematics, University of Southern Mississippi, Hattiesburg, MS 39406 (2005).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[25] A. Imamov,  M. Dzhurabaev, Splines in S.L. Sobolev spaces (Сплайны в пространствах С.Л.Соболева). Deposited manuscript. Dep. UzNIINTI, No 880, 1989.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[26] J. Dix, R. Ogden, An Interpolation Scheme with Radial Basis in Sobolev Spaces H^s(R^n). Rocky Mountain J. Math. Vol. 24, No.4,  1994.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Simple-Normal-Splines-Examples","page":"Normal Splines Method","title":"Simple Normal Splines Examples","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In this section we illustrate the normal spline interpolation method with a few simple examples.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let's there is the following information of a smooth function varphi (xy)  (xy) in R^2:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\ntag1\r\n varphi (0 0) = 0  \r\n\r\n  frac partialvarphi  partialx  (0 0) =  1  \r\n\r\n frac partialvarphi  partialy  (0 0) =  1  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and it is necessary to reconstruct varphi using this data.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We assume this function is an element of the Bessel potential space H^25_varepsilon (R^2), thereby it can be treated as a continuously differentiable function. We construct a normal spline sigma_1^(25) approximating varphi:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\nsigma_1^(25) = rm argmin   varphi ^2_H^25_varepsilon  (1)    forall varphi in H^25_varepsilon (R^2)   \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"This spline can be presented as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"sigma_1^(25) = mu_1  h_1 +  mu_1  h_1 +  mu_2  h_2  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  h_1 (eta_1 eta_2 varepsilon) = exp (-varepsilon sqrteta_1^2 + eta_2^2) (1 + varepsilon sqrteta_1^2 + eta_2^2)  \r\n\r\n  h_1 (eta_1 eta_2 varepsilon) = varepsilon^2 exp (-varepsilon sqrteta_1^2 + eta_2^2) (eta_1 + eta_2)  \r\n\r\n  h_2 (eta_1 eta_2 varepsilon)  =   h_1 (eta_1 eta_2 varepsilon)      (eta_1 eta_2) in R^2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and coefficients (mu_1 mu_1 mu_2) are defined from the system:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginbmatrix\r\n   1  0  0  \r\n   0  2varepsilon^2  0  \r\n   0  0  2varepsilon^2  \r\n   endbmatrix left beginarrayc mu_1  mu_1  mu_2 endarray right =\r\nleft beginarrayc 0  1  1 endarray right  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Eventually","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"sigma_1^(25) (x y varepsilon) = exp (-varepsilon sqrtx^2 + y^2) (x + y)   quad (xy) in R^2","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"(Image: Example 1A)","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Fig.1 Spline sigma_1^(25)  varepsilon = 1","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"(Image: Example 2A)","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Fig.2 Spline sigma_1^(25)  varepsilon = 01","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Now let function varphi (xy)  (xy) in R^2 is a twice continuously differentiable function which satisfies constraints:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\ntag2\r\n  varphi (0 0) = 0  \r\n\r\n   frac partialvarphi  partialx  (0 0) + frac partialvarphi  partialy  (0 0)  =  2  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"We approximate it by constructing a normal spline sigma_1^(35) in H^35_varepsilon (R^2): ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n sigma_1^(35) = rm argmin   varphi ^2_H^35_varepsilon  (2)   forall varphi in H^35_varepsilon (R^2)    \r\n sigma_1^(35) = mu_1  h_1 +  mu_1  h_1  \r\nendaligned ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  h_1 (eta_1 eta_2 varepsilon) = exp (-varepsilon sqrteta_1^2 + eta_2^2) (3 + 3varepsilon sqrteta_1^2 + eta_2^2 + varepsilon^2 (eta_1^2 + eta_2^2))  \r\n\r\n  h_1 (eta_1 eta_2 varepsilon) = varepsilon^2 exp (-varepsilon sqrteta_1^2 + eta_2^2) (1 +varepsilon sqrteta_1^2 + eta_2^2) (eta_1 + eta_2)  \r\nendaligned ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and coefficients (mu_1 mu_1) are defined from the system:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginbmatrix\r\n   3   0  \r\n   0  2varepsilon^2 \r\n   endbmatrix left beginarrayc mu_1  mu_1 endarray right =\r\nleft beginarrayc 0  2 endarray right  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Therefore","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n sigma_1^(35) (x y varepsilon) = exp (-varepsilon sqrtx^2 + y^2) (1 + varepsilon sqrtx^2 + y^2) (x + y)   \r\n \r\n (xy) in R^2\r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"As the last example consider a problem of reconstructing a continuously differentiable function varphi (x)   x in R, which satisfies constraint","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag3\r\nfrac dvarphi dx (0) = 1  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and it is closest to function z(x) = 2 x  x in R. We approximate it by constructing a normal spline sigma_1^(2) in H^2_varepsilon (R):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n sigma_1^(2) = rm argmin   varphi  - z ^2_H^2_varepsilon  (3)    forall varphi in H^2_varepsilon (R)    \r\n\r\n sigma_1^(2) = z + mu_1  h_1 = 2x + mu_1  h_1   \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Performing calculations analogous to previous ones, we'll receive:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"sigma_1^(2) (x varepsilon) = 2 x - x exp (-varepsilon x)   quad x in R","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Comparison-with-Polyharmonic-Splines","page":"Normal Splines Method","title":"Comparison with Polyharmonic Splines","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Interpolating normal spline sigma is solution of the variational problem:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag1\r\n   f ^2 = int ( varepsilon ^2  +  xi ^2 )^s  mathcal F f(xi) ^2   d xi  to min    qquad forall f in H^s_varepsilon (R^n)   quad s  fracn2   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag2\r\n f(p_i) =  u_i   quad  p_i in R^n   qquad i = 1 2 dots n  qquad qquadqquadqquadqquadqquadqquad ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here H^s_varepsilon (R^n) is Bessel potential space, which is defined as:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0  quad  s  fracn2   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. Space  H^s_varepsilon is a Hilbert space (see Interpolating Normal Splines).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"It can be shown that for any positive integer m the space H^m_varepsilon (R^n) consists of all square integrable functions whose derivatives in the sense of distributions up to order m are square integrable [1]. The norm on H^m_varepsilon (R^n) can be defined by","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" varphi  = left( int Big  varepsilon^2  varphi (x) ^2  + sum_alpha = m fracmalpha D^alpha varphi (x) ^2 Big \r\n   d x  \r\n right)^12  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The corresponding inner product has the form","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"langle varphi  psi rangle =\r\nleft( int Big  varepsilon^2 varphi (x) overlinepsi (x)  + sum_alpha = m fracmalpha D^alpha varphi (x) overlineD^alpha psi (x)  Big \r\n   d x  \r\n right)^12 ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here alpha = (alpha_1 dots alpha_n ) is multi-index with nonnegative integral entries,  alpha  = alpha_1 + dots + alpha_n,  alpha  = alpha_1  dots alpha_n  and D^alpha varphi (x) = frac partial^alphavarphi  partialx_1^alpha_1 dots x_n^alpha_n.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The norms  varphi  and  varphi  are equivalent and space H^m_varepsilon (R^n) coincides with Sobolev space. Therefore the problem (1), (2) can be written as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag3\r\n   f ^2 = int Big  varepsilon^2  f(x) ^2  + sum_alpha = m fracmalpha D^alpha f(x) ^2 Big \r\n   d x   to min       forall f in W^m_2 (R^n)    varepsilon gt 0    m gt fracn2   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag4\r\n f(p_i) =  u_i   quad  p_i in R^n   qquad i = 1 2 dots n  qquad qquad qquad qquadqquad qquadqquadqquad  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here W^m_2 (R^n) is Sobolev space. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Normal spline sigma always exist if all points p_i are different and it is unique.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Polyharmonic D^m spline sigma_D^m is the the result of minimization of the quadratic functional (Sobolev semi-norm) ([3], [4])","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag5\r\n intlimits_Omega sum_alpha = m fracmalpha D^alpha f(x) ^2    d x   to min    qquad forall f in W^m_2 (Omega)   quad m  fracn2","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"under interpolation constraints","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag6\r\n f(p_i) =  u_i   quad  p_i in Omega   qquad i = 1 2 dots n  qquad qquadqquadqquadqquad ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here W^m_2 (Omega) is Sobolev space (Omega subset R^n is a bounded and sufficiently regular ([3, 4]) domain in R^n).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"D^m spline sigma_D^m always exist if all points p_i are different and it is unique if set p_i contains P_m-1- unisolvent set [3].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Comparing the variational problems (3),(4) and (5),(6) we can expect that their solutions – the normal spline sigma and D^m spline sigma_D^m will have the similar properties when varepsilon to 0 in (3).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Also, in general case (when s is not an integer number), we could expect that once the normal spline scaling (\"shape\") parameter varepsilon is small enough, the normal spline sigma will have similar properties as D^ms spline sigma_D^ms of the corresponding smoothness constructed in the appropriate intermediate Beppo-Levi space ([2, 4]).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] M. Agranovich, Sobolev Spaces, Their Generalizations and Elliptic Problems in Smooth and Lipschitz Domains, Springer, Switzerland, 2015.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] F. Utreras, Recent results on multivariate smoothing splines, in Multivariate Approximation and Interpolation, ISNM 94, W. Haussmann and K. Jetter (eds.), Birkhauser, Basel, 299–312, 1990.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] A. Bezhaev, V. Vasilenko, Variational Theory of Splines, Springer US, 2001.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[4] J. Duchon, Splines minimizing rotation-invariant semi-norms in Sobolev spaces, Lect. Notes in Math., Vol. 571, Springer, Berlin, 1977","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Convergence-and-Error-Bounds","page":"Normal Splines Method","title":"Convergence and Error Bounds","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"....","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"....","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Quadratic-Programming-in-Hilbert-space","page":"Normal Splines Method","title":"Quadratic Programming in Hilbert space","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Here we describe an algorithm of finding a normal solution of linear inequality system in Hilbert space. An original version of the algorithm was developed by V. Gorbunov and published in [3]. A modified version of that algorithm was presented in [6].","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let H be a Hilbert space with inner product langle cdot   cdot rangle_H and the induced norm  cdot _H, there are elements h_i in H, numbers u_i  1 le i le M+L and positive numbers  delta _i  1 le i le M. It is required to minimize functional J:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag1\r\n   (J varphi) =   varphi _H ^2 to min  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"subject to constraints","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag2\r\n    langle h_i  varphi rangle_H = u_i  \r\n    qquadqquadqquad 1 le i le L  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag3\r\n     langle h_i+L  varphi rangle_H - u_i+L  le delta _i  \r\n    quad   1 le i le M    varphi in H","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The elements h_i  1 le i le M+L are assumed to be linearly independent (thereby the system (2), (3) is compatible). Solution of the problem (1)—(3) obviously exists and it is unique as a solution of the problem of finding a projection of zero element onto a nonempty convex closed set in Hilbert space [1, 5]. Expanding the modules in (3) we rewrite the system (2), (3) in form:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag4\r\n    langle h_i  varphi rangle_H = b_i quad 1 le i le L  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag5\r\nqquad  langle h_i  varphi rangle_H le b_i quad L+1 le i le N  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  N = L + 2M  \r\n \r\n S = L + M   \r\n \r\n   b_i = u_i    quad  1 le i le L  \r\n \r\n   b_i+L = u_i+L + delta _i    \r\n  \r\n   b_i+S = -u_i+L + delta _i    \r\n \r\n   h_i+S = -h_i+L   quad  1 leq i leq M  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let Phi be a convex set defined by constraints (4) and (5). We denote","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  I_1 = lbrace 1 dots  L rbrace    quad I_2 = lbrace L+1 dots  N rbrace   \r\n\r\n   I = I_1 cup I_2 = lbrace 1 dots  N rbrace  \r\n\r\n   A(varphi) = lbrace i in I  langle h_i  varphi rangle_H = b_i rbrace  \r\n   P(varphi) = I setminus A(varphi)  \r\n\r\n   Psi(varphi) =  psi in H  langle h_i psi rangle_H = b_i    i in A(varphi)   \r\n\r\n   g_ij = langle h_i  h_j rangle_H   quad 1 le ij le S  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Feasible region of the Psi(varphi)  varphi in Phi is a face of set Phi containing varphi. If A(varphi) is empty (it is possible when L =0) then Psi(varphi) = H. ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"In accordance with optimality conditions [4, 5] the solution of the problem (1), (4), (5) can be represented as: ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\ntag6\r\n qquad sigma = sum _i=1 ^L mu _i h_i + sum _i=L+1 ^M+L (mu _i - mu _i+M) h_i  \r\n \r\n   qquad  mu_i le 0   quad mu_i+M le 0   quad  L+1 le i le L+M  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag7\r\n mu_i (langle h_i  sigma rangle_H - b_i ) = 0     quad  L+1 le i le N  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag8\r\n mu_i  mu_i+M = 0   qquad qquad     L+1 le i le S  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Here complementary slackness conditions (7) means that mu_k = 0 for k in P(sigma) and the relations (8) reflect the fact that any pair of constraints (5) with indices i and i + M cannot be simultaneously active on the solution. Thereby there are at most S non-trivial coefficients mu_i in formula (6) and actual dimension of the problem (1), (4), (5) is S.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let hatsigma be the normal solution of the system (4), then it can be written as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    hatsigma =  sum _i=1 ^L mu _i h_i  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where coefficients mu_i are determined from the system of linear equations with symmetric positive definite Gram matrix g_ij of the linear independent elements h_i:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    sum _j=1 ^L g_ij mu _j = b_i    quad 1 le i le L  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"If L = 0 then there are no constraints (4) and hatsigma = 0. If hatsigma satisfies constraints (5), that is, the inequalities","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    langle h_i  hatsigma rangle_H le b_i     qquad L+1 le i le N  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"which can be written like this:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    sum _j=1 ^L g_ij mu _j le b_i       qquad L+1 le i le N  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"then hatsigma is a solution to the original problem (1), (4), (5), i.e. sigma = hatsigma.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Consider nontrivial case when hatsigma does not satisfy constraints (5). In this case sigma belongs to the boundary of the set Phi and it is a projection of zero element of space H onto the set Psi (sigma). Projection vartheta of zero element of space H onto the set Psi (varphi) can be presented as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  vartheta  =  sum _i in A(varphi) mu _i h_i  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where factors mu_i are defined from the system of linear equations with symmetric positive definite matrix","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    sum _j in A(varphi) g_ij mu _j = b_i       qquad i in A(varphi)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"If factors mu_i, i in I_2 cap A(varphi) corresponding to the inequality constraints are nonpositive, then we can set mu_i = 0 for i in P(varphi) and get all conditions (8)—(10) satisfied, thereby vartheta  = sigma is a solution of the problem under consideration. The following algorithm is based on this remark.  Let's describe its iteration.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Let's sigma^ k be a feasible point of the system (4), (5):","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag9\r\n  sigma^k = sum _i = 1^N mu_i^k h_i  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where there are at most S non-zero multipliers mu_i^k.  A projection of zero element of space H onto the set Psi (vartheta^k) we denote as vartheta^k,  and A_k = A(sigma^k), P_k = P(sigma^k) = I setminus A_k. Then vartheta^k can be presented as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" qquadqquadqquadqquadqquad vartheta^k = sum _i in A_k lambda_i^k h_i = sum _i = 1^N lambda_i^k h_i   quad lambda_i^k = 0      forall i in P_k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag10\r\n  sum _j in A_k g_ij lambda_j^k = b_i     quad i in A_k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"There are two possible cases: the element vartheta^k is feasible or it is not feasible. In the first case we check the optimality conditions, namely: if lambda_i^k le 0   forall i in I_2 then  vartheta^k is the solution of the problem. If the optimality conditions are not satisfied then we set sigma^k+1 = vartheta^k, find an index i in A_k such that lambda_i^k  0 and remove it from A_k. In the second case sigma^k+1 will be defined as a feasible point of the ray vartheta (t)","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"tag11\r\n  vartheta (t) = sigma^k + t (vartheta^k - sigma^k)   ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"math such that it is closest to the vartheta^k. Denote t^k_min the corresponding value of t and i_k in P_k — related number of the violated constraint. This index i_k will be added to A_k forming A_k+1. Since all sigma^k are feasible points, the minimization process proceeds within the feasible region and value of  sigma^k _H is not increasing. The minimization process is finite because of linear independence of the constraints, it eliminates the possibility of the algorithm cycling. The feasibility of the vartheta^k can be checked as follows. Introduce the values e_i^k   k in P_k:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" e_i^k = langle h_i  vartheta^k - sigma^k rangle_H =  sum _j=1^N g_ij(lambda_j^k - mu _j^k)    quad i in P_k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"if e_i^k  0 then constraint with number i can be violated at the transition from sigma^k to point vartheta^k, in a case when e_i^k  0 the constraint with number i + M can be violated. For all i in P_k compute values","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  t_i^k = begincases\r\n           frac b_i - langle h_i  sigma^k rangle_He_i^k  \r\n                          quad e_i^k  0  cr cr\r\n           frac -b_i+M - langle h_i+M  sigma^k rangle_He_i^k  \r\n                          quad e_i^k  0  cr cr\r\n           1   quad e_i^k = 0 cr\r\n               endcases  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"langle h_i  sigma^k rangle_H =   sum _j=1^N g_ij mu _j^k  \r\nqquad \r\n langle h_i+M  sigma^k rangle_H =\r\n                 sum _j=1^N g_i+Mj mu _j^k   quad i in P_k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"here all t_i^k ge 0. Now the maximum feasible step t^k_min is computed as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    t^k_min = min_i in P_k  t_i^k  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and vartheta^k is feasible if and only if t^k_min ge 1 (see (11)).","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Thereby the algorithm's iteration consist of seven steps:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Initialization. Let sigma^0 be a feasible point of the system (4), (5) and mu_i^0  are corresponding multipliers (9).\nCompute multipliers lambda_j^k  i in A_k as solution of the system (10).\nIf  A_k  = S then go to Step 6.\nCompute t_i^k  forall i in P_k. Find t^k_min and the corresponding index i_k. \nIf t^k_min  1 (projection vartheta^k is not feasible) then set mu_i^k+1 = mu_i^k + t^k_min (lambda_i^k - mu_i^k)   i in A_k and A_k+1 = A_k cup  i_k . Return to Step 1.\nProjection vartheta^k is feasible. If exists index i_p  i_p in A_k such that lambda_i_p^k  0 then set A_k+1 = A_k setminus  i_p   and mu_i^k+1 = lambda_i^k    i in A_k+1. Return to Step 1.\nSet sigma = vartheta^k. Stop.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The algorithm starts from an initial feasible point of the system (4), (5). Such point sigma^0 can be defined as the normal solution of the system","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":" langle h_i  varphi rangle_H = u_i  quad 1 le i le S  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and can be presented as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  sigma^0 = sum _i = 1^S mu_i^0 h_i  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where multipliers mu_i^0 are defined from the system","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  sum _j=1 ^S g_ij mu _j^0  = u_i       qquad 1 le i le  S  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"The algorithm described here implements a variant of the active set method [2] with the simplest form of the minimized functional (1). It can also be treated as a variant of the conjugate gradient method [7] and allows to solve the considered problem by a finite number of operations. The conjugate gradient method in this case is reduced into the problem of finding the projection vartheta^ k, that is, into solving of system (10). Infinite dimensionality of the space H for this algorithm is irrelevant. The most computationally costly part of the algorithm is calculation of projection vartheta^k by solving system (10). Matrices of all systems (10) are positive definite because of linear independence of elements h_i, and it is convenient to use Cholesky decomposition to factorize them . At every step of the algorithm a constraint is added to or removed from the current active set and the system (10) matrix gets modified by the corresponding row and symmetric column addition or deletion. It is possible to get Cholesky factor of the modified matrix without computing the full matrix factorization, it allows greatly reduce the total amount of computations.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"This algorithm can be also applied in case when instead of modular constraints (3) there are one-sided inequality constraints","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    langle h_i+L  varphi rangle_H le u_i+L   quad 1 le i le M  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"for that it is enough to set ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  b_i+L = u_i+L   quad  b_i+S = -infty   quad 1 le i le M  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] A. Balakrishnan, Applied Functional Analysis, Springer-Verlag, New York, 1976.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2]  P. Gill, W. Murray, M. Wright, Practical Optimization, Academic Press, London, 1981.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] V. Gorbunov, The method of reduction of unstable computational problems (Metody reduktsii neustoichivykh vychislitel'nkh zadach), Ilim, 1984.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[4] A. Ioffe, V. Tikhomirov, Theory of extremal problems, North-Holland, Amsterdam, 1979.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[5] P.-J. Laurent, Approximation et optimization, Paris, 1972.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[6] I. Kohanovsky, Data approximation using multidimensional normal splines. Unpublished manuscript. 1996.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[7] B. Pshenichnyi, Yu. Danilin, Numerical methods in extremal problems,  Mir Publishers, Moscow, 1978.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"","category":"page"},{"location":"Normal-Splines-Method/#Algorithms-for-updating-Cholesky-factorization","page":"Normal Splines Method","title":"Algorithms for updating Cholesky factorization","text":"","category":"section"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"A problem of updating Cholesky factorization was treated in [1], [2] and [3]. Here algorithms taken from these works are described. These algorithms are for computing a factorization tilde A = tilde L tilde L^T where tilde A is a matrix received of the matrix A = L L^T after a row and the symmetric column were added or deleted from A. Let A in R^n times n is a symmetric positive definite matrix. Applying Cholesky method to A yields the factorization A = L L^T where L is a lower triangular matrix with positive diagonal elements. Suppose tilde A is a positive definite matrix created by adding a row and the symmetric  column to A:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    tilde A = left( beginarraycc\r\n       A  d \r\n       d^T  gamma\r\n      endarray\r\n      right)   qquad d^T  in R^n","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Then its Cholesky factorization is [2]:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    tilde L = left( beginarraycc\r\n       L  \r\n       e^T  alpha\r\n      endarray\r\n      right)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"     e = L^-1 d  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"and","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    alpha = sqrt tau    quad tau = gamma - e^T e quad tau  0","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"If tau le 0 then tilde A is not positive definite.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Now assume tilde A is obtained by deleting the r^th row and column from A. Matrix tilde A is the positive definite matrix (as any principal square submatrix of the positive definite matrix). It is shown in [1],[3] how to get tilde L from L in such case. Let us partition A and L along the r^th row and column:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    A = left( beginarrayccc\r\n          A_11  a_1r  A_12 \r\n          a_1r^T  a_rr  a_2r^T \r\n          A_21  a_2r  A_22\r\n      endarray\r\n     right)   qquad\r\n    L = left( beginarrayccc\r\n   L_11   \r\n   l_1r^T  l_rr   \r\n   L_21  l_2r  L_22\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Then tilde A can be written as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    tilde A = left( beginarraycc\r\n    A_11   A_12 \r\n    A_21   A_22\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"By deleting the r^th row from L we get the matrix","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    H = left( beginarrayccc\r\n  L_11     \r\n  L_21  l_2r  L_22\r\n    endarray\r\n     right) ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"with the property that H H^T = tilde A. Factor tilde L can be received from H by applying Givens rotations to the matrix elements h_r r+1 h_r+1 r+2 dots  h_n-1 n and deleting the last column of the obtained matrix tilde H:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    tilde H = H R = left( beginarrayccc\r\n  L_11 \r\n  L_21   tilde L_22  0\r\n    endarray\r\n     right) =  Bigl( tilde L  0 Bigr)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where R=R_0 R_1 dots R_n - 1 - r is the matrix of Givens rotations, L_11 and tilde L_22 - lower triangle matrices, and","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  tilde L = left( beginarraycc\r\n  L_11    \r\n  L_21   tilde L_22\r\n    endarray  right)    \r\n\r\n tilde H  tilde H^T = H R R^T H^T = H H^T = tilde A   \r\n\r\n  tilde H  tilde H^T = tilde L tilde L^T   quad tilde L tilde L^T = tilde A  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Orthogonal matrix R_t  (0 le t le n - 1 -r) R_t in R^n times n which defines the Givens rotation annulating (r+t  r+t+1)th element of the H_k R_0 dots R_t-1 matrix is defined as","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"    R_t = left( beginarraycccccc\r\n   1       ldots  0       0       ldots  0 \r\n   vdots  ldots  ldots  ldots  ldots  vdots \r\n   0       ldots  c       s       ldots  0 \r\n   0       ldots  -s      c       ldots  0 \r\n   vdots  ldots  ldots  ldots  ldots  vdots \r\n   0       ldots  0       0       ldots  1\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where entries ( r+t  r+t ) and ( r+t+1  r+t+1 ) equal c,  ( r+t  r+t+1 ) entry equals s, and ( r+t+1  r+t ) entry equals -s, here c^2 + s^2 = 1. Let's tilde l_ij^t-1 - coefficients of matrix H_k R_0 dots R_t-1 (tilde l_ij^-1 - coefficients of H_k) and","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  c = frac tilde l_r+tr+t^t-1 \r\n sqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2    \r\nquad\r\n  s = frac tilde l_r+tr+t+1^t-1 \r\n sqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2    ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Then matrix H_k R_0 dots R_t will differ from H_k R_0 dots R_t-1 with entries of ( r+t ) и ( r+t+1 ) columns only, thereby","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  tilde l_ir+t^t = tilde l_ir+t^t-1 = 0     \r\n     tilde l_ir+t+1^t = tilde l_ir+t+1^t-1 = 0  \r\n     qquad qquad qquad     1 le i le r + t  - 1   \r\n\r\n  tilde l_ir+t^t = c tilde l_ir+t^t-1 +  s tilde l_ir+t+1^t-1  \r\n    \r\ntilde l_ir+t+1^t = -s tilde l_ir+t^t-1 +  c tilde l_ir+t+1^t-1 \r\n     quad  r + t le i le n - 1  \r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"where","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"  tilde l_r+tr+t^t =\r\nsqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2   \r\nqquad\r\n  tilde l_r+tr+t+1^t = 0     ","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Also, coefficient tilde l_r+tr+t^t is a nonnegative one. In order to avoid unnecessary overflow or underflow during computation of c and s, it was recommended [3] to calculate value of the square root w = sqrtx^2 + y^2 as folows:","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"beginaligned\r\n  v = max  x  y    qquad u = min  x  y   \r\n\r\n w = begincases v sqrt 1 + left( fracuv right)^2   \r\n                    quad v ne 0 cr cr\r\n              0   quad v = 0 cr\r\n      endcases  \r\n\r\nendaligned","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"Applying the this technique to Cholesky factorization allows significally reduce the complexity of calculations. So, in case of adding a row and the symmetric column to the original matrix it will be necessary to carry out about n^2 flops instead of about frac (n + 1) ^ 3 3 flops for the direct calculation of the new Cholesky factor. In the case of deleting a row and the symmetric column from the original matrix, the new Cholesky factor can be obtained with about 3(n - r)^2 flops (the worst case requires about 3 (n - 1) ^ 2 operations) instead of about frac (n - 1) ^ 3 3 flops required for its direct calculation.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"References","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[1] T. F. Coleman, L. A. Hulbert, A direct active set  algorithm for large sparse quadratic programs with simple bounds, Mathematical Programming, 45, 1989.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[2] J. A. George, J. W-H. Liu, Computer Solution of Large Sparse Positive Definite Systems, Prentice-Hall, 1981.","category":"page"},{"location":"Normal-Splines-Method/","page":"Normal Splines Method","title":"Normal Splines Method","text":"[3] C. L. Lawson, R. J. Hanson, Solving least squares problems, SIAM, 1995.","category":"page"},{"location":"Public-API/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"Public-API/#API-Summary","page":"Public API","title":"API Summary","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Function Description\nprepare Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem.\nconstruct Construct the spline by calculating its coefficients.\ninterpolate Prepare and construct the spline.\nevaluate Evaluate the spline value at the required locations\nevaluate_one Evaluate the spline value at the required location\nevaluate_gradient Evaluate gradient of the spline at the required location.\nevaluate_derivative Evaluate the 1D spline derivative at the required location.\nestimate_accuracy Estimate accuracy of the function interpolation result.\nestimate_cond Estimate the Gram matrix 1-norm condition number.\nestimate_epsilon Estimate the 'scaling parameter' of Bessel potential space the spline being built in.\nget_epsilon Get the 'scaling parameter' of Bessel potential space the normal spline was built in.\nget_cond Get the Gram matrix spectral condition number.","category":"page"},{"location":"Public-API/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"prepare\r\nconstruct\r\ninterpolate\r\nevaluate\r\nevaluate_one\r\nevaluate_gradient\r\nevaluate_derivative\r\nestimate_accuracy\r\nestimate_cond\r\nget_epsilon\r\nestimate_epsilon\r\nget_cond","category":"page"},{"location":"Public-API/#NormalHermiteSplines.prepare","page":"Public API","title":"NormalHermiteSplines.prepare","text":"prepare(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes.           It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes.            This should be an n×n_2 matrix, where n is dimension of the sampled space and            n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.       This should be an n×n_2 matrix, where n is dimension of the sampled space and       n_2 is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: function value interpolation nodes.          This should be an n_1 vector where n_1 is the number of function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the 1D interpolating normal spline by constructing and factoring a Gram matrix of the problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: function value interpolation nodes.          This should be an n_1 vector where n_1 is the number of function value nodes.\nd_nodes: The function derivatives nodes.            This should be an n_2 vector where n_2 is the number of function derivatives nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.construct","page":"Public API","title":"NormalHermiteSplines.construct","text":"construct(spline::NormalSpline{T, RK}, values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\nconstruct(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\nd_values: function directional derivative values at d_nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.interpolate","page":"Public API","title":"NormalHermiteSplines.interpolate","text":"interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nd_nodes: The function directional derivative nodes.           This should be an n×n_2 matrix, where n is dimension of the sampled space and           n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.      This should be an n×n_2 matrix, where n is dimension of the sampled space and      n_2 is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.\nd_values: function directional derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: function value interpolation nodes.          This should be an n_1 vector where n_1 is the number of function value nodes.\nvalues: function values at n_1 interpolation nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, d_nodes::Vector{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the 1D interpolating normal spline.\n\nArguments\n\nnodes: function value interpolation nodes.          This should be an n_1 vector where n_1 is the number of function value nodes.\nvalues: function values at nodes nodes.\nd_nodes: The function derivatives nodes.            This should be an n_2 vector where n_2 is the number of function derivatives nodes.\nd_values: function derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate","page":"Public API","title":"NormalHermiteSplines.evaluate","text":"evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values at the locations defined in points.\n\nArguments\n\nspline: theNormalSplineobject returned byinterpolateorconstruct` function.\npoints: locations at which spline values are evaluating.           This should be an n×m matrix, where n is dimension of the sampled space           and m is the number of locations where spline values are evaluating.           It means that each column in the matrix defines one location.\n\nReturn: Vector{T} of the spline values at the locations defined in points.\n\n\n\n\n\nevaluate(spline::NormalSpline{T, RK}, points::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values/value at the points locations.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoints: locations at which spline values are evaluating.           This should be a vector of size m where m is the number of evaluating points.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_one","page":"Public API","title":"NormalHermiteSplines.evaluate_one","text":"evaluate_one(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nReturn: the spline value at the location defined in point.\n\n\n\n\n\nevaluate_one(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_gradient","page":"Public API","title":"NormalHermiteSplines.evaluate_gradient","text":"evaluate_gradient(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate gradient of the spline at the location defined in point.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which gradient value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nNote: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturn: Vector{T} - gradient of the spline at the location defined in point.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_derivative","page":"Public API","title":"NormalHermiteSplines.evaluate_derivative","text":"evaluate_derivative(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline derivative at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline derivative is evaluating.\n\nNote: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturn: the spline derivative value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_accuracy","page":"Public API","title":"NormalHermiteSplines.estimate_accuracy","text":"estimate_accuracy(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nAssess accuracy of interpolation results by analyzing residuals.\n\nArguments\n\nspline: the NormalSpline object returned by construct or interpolate function.\n\nReturn: an estimation of the number of significant digits in the interpolation result.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_cond","page":"Public API","title":"NormalHermiteSplines.estimate_cond","text":"estimate_cond(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet an estimation of the Gram matrix condition number. It needs the spline object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: an estimation of the Gram matrix condition number.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_epsilon","page":"Public API","title":"NormalHermiteSplines.get_epsilon","text":"get_epsilon(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet the 'scaling parameter' of Bessel Potential space the spline was built in.\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: ε - the 'scaling parameter'.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_epsilon","page":"Public API","title":"NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in.          It must be a struct object of the following type:            RK_H0 if the spline is constructing as a continuous function,            RK_H1 if the spline is constructing as a differentiable function,            RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nd_nodes: The function directional derivative nodes.          This should be an n×n_2 matrix, where n is dimension of the sampled space and          n_2 is the number of function directional derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in.           It must be a struct object of the following type:           RK_H1 if the spline is constructing as a differentiable function,           RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_cond","page":"Public API","title":"NormalHermiteSplines.get_cond","text":"get_cond(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: a value of the Gram matrix spectral condition number.\n\n\n\n\n\nget_cond(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes.           It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes.            This should be an n×n_2 matrix, where n is dimension of the sampled space and            n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.       This should be an n×n_2 matrix, where n is dimension of the sampled space and       n_2 is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: a value of the Gram matrix spectral condition number.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"Public-API/#Bessel-potential-Space-Reproducing-Kernels","page":"Public API","title":"Bessel potential Space Reproducing Kernels","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"RK_H0\r\nRK_H1\r\nRK_H2","category":"page"},{"location":"Public-API/#NormalHermiteSplines.RK_H0","page":"Public API","title":"NormalHermiteSplines.RK_H0","text":"struct RK_H0{T <: AbstractFloat} <: ReproducingKernel_0\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 12_ε (R^n) ('Basic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H1","page":"Public API","title":"NormalHermiteSplines.RK_H1","text":"struct RK_H1{T <: AbstractFloat} <: ReproducingKernel_1\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 32_ε (R^n) ('Linear Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (1 + varepsilon xi  - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H2","page":"Public API","title":"NormalHermiteSplines.RK_H2","text":"struct RK_H2{T <: AbstractFloat} <: ReproducingKernel_2\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 52_ε (R^n) ('Quadratic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (3 + 3varepsilon xi  - eta + varepsilon ^2 xi - eta ^2 )  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalSpline-structure","page":"Public API","title":"NormalSpline structure","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"NormalSpline","category":"page"},{"location":"Public-API/#NormalHermiteSplines.NormalSpline","page":"Public API","title":"NormalHermiteSplines.NormalSpline","text":"struct NormalSpline{T, RK} <: AbstractSpline where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nDefine a structure containing full information of a normal spline\n\nFields\n\n_kernel: a reproducing kernel spline was built with\n_compression: factor of transforming the original node locations into unit hypercube\n_nodes: transformed function value nodes\n_values: function values at interpolation nodes\n_d_nodes: transformed function directional derivative nodes\n_es: normalized derivative directions\n_d_values: function directional derivative values\n_min_bound: minimal bounds of the original node locations area\n_gram: Gram matrix of the problem\n_chol: Cholesky factorization of the Gram matrix\n_mu: spline coefficients\n_cond: estimation of the Gram matrix condition number\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Order = [:function, :type]","category":"page"}]
}

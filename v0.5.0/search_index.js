var documenterSearchIndex = {"docs":
[{"location":"Usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"Usage/#D-interpolation-case","page":"Example Usage","title":"1D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function f(x)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"f(x) =\r\n    begincases\r\n       0     1 le x lt 6 \r\n       1     6 le x le 10 \r\n       -x5 + 3     6 le x le 15 \r\n       0     15 le x le 20 \r\n    endcases","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"by values of the function in nodes 1 2 3  20 (case A) and by values of the function and values of its first derivatives in the same nodes (case B). Firstly we'll build a spline using the reproducing kernel RK_H1():","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = quote\r\n    using Random\r\n    using NormalHermiteSplines\r\nend","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the 'scaling parameter' the spline being built with\r\n    ε_estimation = estimate_epsilon(x, RK_H1())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # Build a differentiable spline by values of function in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = prepare(x, RK_H1())\r\n    \r\n    # A value of the 'scaling parameter' the spline was built with.\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # Construct the spline for given 'u' values\r\n    spline = construct(spline, u)\r\n\r\n    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)        # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Construct spline by different function values in nodes and evaluate new spline at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    u2 = 2.0 .* u\r\n    spline = construct(spline, u2)\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    s = x                         # function first derivative nodes\r\n    v = x.*0.0                    # function first derivative values\r\n    for i in 11:14\r\n        v[i] = -0.2\r\n    end\r\n\r\n    # Build a differentiable spline by values of function,\r\n    # and values of its first derivatives in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = interpolate(x, u, s, v, RK_H1())\r\n\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)      # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                  # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"C) ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Now let's interpolate function f(x) using a spline built with reproducing kernel RK_H0:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    # Build a continuous spline by values of function in nodes\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = interpolate(x, u, RK_H0())\r\n\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = collect(1.0:0.2:20)        # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1C)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This spline is an infinitely differentiable function everywhere excepting the spline nodes. Its derivative does not exist at spline nodes but we can differentiate the spline at other points. Let's evaluate the spline derivatives at the same evaluation points (which do not coincide with the spline nodes):","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/#D-interpolation-case-2","page":"Example Usage","title":"2D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function phi (xy)  = frac23cos(10x)sin(10y) + frac13sin(10xy) defined on unit square Omega = 01^2.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-cf-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-t-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-32,1.png\" width=\"197\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We built a spline using function phi values sampled on set of 100 pseudo-random nodes uniformly distributed on Omega (case A).","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                        Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-32,32,1,2,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using function phi values sampled on set of 100 pseudo-random nodes uniformly distributed on Omega and 80 function phi gradient values defined at nodes located on the border of domain Omega (case B):","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-33,1.png\" width=\"197\"/> ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"here red dots represent the function phi gradient nodes. ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                         Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-33,33,1,2,1.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Following is the code example for case A:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    # generating 100 uniform random nodes\r\n    m = 100\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 101x101 on [0, 1]x[0, 1]\r\n    t = 100\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n\r\n    t1 = t + 1\r\n    n = t1^2\r\n    grid = Matrix{Float64}(undef, 2, n)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    f = Vector{Float64}(undef, n)\r\n    for i = 1:n\r\n        x = grid[1,i]\r\n        y = grid[2,i]\r\n        f[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # Here spline is constructed with RK_H2 kernel,\r\n    # the value of the 'scaling parameter' ε is estimated\r\n    # in the interpolate procedure.\r\n    rk = RK_H2()\r\n    spline = interpolate(nodes, u, rk)\r\n    #\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate(spline, grid)\r\n    # Return the Root Mean Square Error (RMSE) of interpolation\r\n    rmse = sqrt(sum((f .- σ).^2)) / sqrt(length(f))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"   # Return the Maximum Absolute Error (MAE) of interpolation\r\n   mae = maximum(abs.(f .- σ))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Corresponding code example for case B:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    function get_2D_border_nodes(m::Int)\r\n        mat0 = [0.0 0.0; 0.0 1.0; 1.0 0.0; 1.0 1.0]'\r\n        if m < 1\r\n            return mat0\r\n        end\r\n        m1 = m + 1\r\n        p = collect(range(1.0/m1, (1.0 - 1.0/m1); step = 1.0/m1))\r\n        ms = m * 4\r\n        mat = Matrix{Float64}(undef, 2, ms)\r\n        for i = 1:m\r\n            mat[1,i] = 0.0\r\n            mat[2,i] = p[i]\r\n        end\r\n        for i = (m+1):(2*m)\r\n            mat[1,i] = 1.0\r\n            mat[2,i] = p[i-m]\r\n        end\r\n        for i = (2*m+1):(3*m)\r\n            mat[1,i] = p[i-2*m]\r\n            mat[2,i] = 0.0\r\n        end\r\n        for i = (3*m+1):(4*m)\r\n            mat[1,i] = p[i-3*m]\r\n            mat[2,i] = 1.0\r\n        end\r\n        w = hcat(mat0, mat)\r\n        return w\r\n    end\r\n\r\n    # generating 100 uniform random nodes\r\n    m = 100\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    bnodes = get_2D_border_nodes(19)   # 80 border nodes \r\n    bn_1 = size(bnodes, 2)\r\n    d_nodes = Matrix{Float64}(undef, 2, bn_1)\r\n    es = Matrix{Float64}(undef, 2, bn_1)\r\n    du = Vector{Float64}(undef, bn_1)\r\n    grad = [0.0; 0.0]\r\n    for i = 1:bn_1\r\n        x = bnodes[1,i]\r\n        y = bnodes[2,i]\r\n        d_nodes[1,i] = x\r\n        d_nodes[2,i] = y\r\n        grad[1] = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n        grad[2] = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0\r\n        es[1,i] = grad[1]            # no need to normalize 'es' vectors\r\n        es[2,i] = grad[2]\r\n        du[i] = sqrt(grad[1]^2 + grad[2]^2)\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 101x101 on [0, 1]x[0, 1]\r\n    t = 100\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n\r\n    t1 = t + 1\r\n    n = t1^2\r\n    grid = Matrix{Float64}(undef, 2, n)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    f = Vector{Float64}(undef, n)\r\n    for i = 1:n\r\n        x = grid[1,i]\r\n        y = grid[2,i]\r\n        f[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # Here spline is constructed with RK_H2 kernel,\r\n    # the 'scaling parameter' ε is defined explicitly.\r\n    rk = RK_H2(1.0)\r\n    spline = interpolate(nodes, u, d_nodes, es, du, rk)\r\n    #\r\n    # A value of the 'scaling parameter' the spline was built with\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the Gram matrix condition number\r\n    cond = estimate_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # An estimation of the interpolation accuracy -\r\n    # number of significant digits in the function value interpolation result.\r\n    significant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate(spline, grid)\r\n    # Return the Root Mean Square Error (RMSE) of interpolation\r\n    rmse = sqrt(sum((f .- σ).^2)) / sqrt(length(f))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"   # Return the Maximum Absolute Error (MAE) of interpolation\r\n   mae = maximum(abs.(f .- σ))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/#Q-and-A","page":"Example Usage","title":"Q & A","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q1. Question: The call","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"spline = interpolate(x, u, RK_H2())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cause the following error: PosDefException: matrix is not positive definite; Cholesky factorization failed. What is a reason of the error and how to resolve it?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A1. Answer: Creating a Bessel potential space reproducing kernel object with omitted scaling parameter ε means that this parameter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too small and corresponding  Gram matrix of the system of linear equations which defines the normal spline coefficients is a very ill-conditioned one and it lost its positive definiteness property because of floating-point rounding errors.  ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"There are two ways to fix it.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We can get the estimated value of the parameter ε by calling get_epsilon function:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"then we can call the interpolate function with a larger value of this parameter:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"larger_ε = 5.0*ε\r\nspline = interpolate(x, u, RK_H2(larger_ε))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We may change the precision of floating point calculations. Namely, it is possible to use Julia standard BigFloat numbers or Double64 - extended precision float type from the package DoubleFloats:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using DoubleFloats\r\n\r\nx = Double64.(x)\r\nu = Double64.(u)\r\nε = Double64(1.0)\r\nspline = interpolate(x, u, RK_H2(ε))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This answer also applies to reproducing kernel object of type RK_H0 or RK_H1.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q2. Question: The following calls","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"spline = interpolate(x, u, RK_H2())\r\nσ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"produce the output which is not quite satisfactoty. Is it possible to improve the quality of interpolation?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A2. Answer: Creating a Bessel potential space reproducing kernel object with omitted scaling parameter ε means that this parameter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too large and it is possible to use a smaller value of ε which can lead to a better quality of interpolation. ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We can get the value of scaling parameter ε by calling get_epsilon function","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and get an estimation of the problem's Gram matrix condition number by calling estimate_cond function as well as an estimation of the number of the significant digits in the interpolation result by calling estimate_accuracy function:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cond = estimate_cond(spline)\r\nsignificant_digits = estimate_accuracy(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"In a case when estimated number of the significant digits is bigger than 10 and estimated condition number is not very large, i.e. it is less than 10^12, we may attempt to build a better interpolating spline by calling interpolate function with a smaller value of the scaling parameter:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"e_smaller = ε/2.0 \r\nspline = interpolate(x, u, RK_H2(e_smaller))\r\ncond = estimate_cond(spline)\r\nsignificant_digits = estimate_accuracy(spline)\r\nσ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Taking into account new cond and significant_digits values we decide of making further correction of the scaling parameter.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"For further information, see Selecting a good value of the scaling parameter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author = \"Igor Kohanovsky\"","category":"page"},{"location":"#NormalHermiteSplines.jl-package","page":"Home","title":"NormalHermiteSplines.jl package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multivariate Normal Hermite-Birkhoff Interpolating Splines in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"NormalHermiteSplines.jl package implements the normal splines method for solving following interpolation problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem:   Given points p_i p_i in R^n_i=1^n_1, s_j s_j in R^n_j=1^n_2 and a set of unit vectors e_j e_j in R^n_j=1^n_2 find a function f such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag1\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n  \r\n frac partialf  partiale_j (s_j) =  v_j   quad  j = 1 2 dots n_2  \r\n\r\n n_1 gt 0       n_2 ge 0  \r\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where frac partialf  partiale_j (s_j) = nabla f(s_j) cdot e_j = sum _k=1^n  frac partialf  partialx_k  (s_j) e_jk is a directional derivative of f at the point s_j in the direction of e_j.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We assume that function f is an element of the Bessel potential space H^s_varepsilon (R^n) which is defined as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s = n2 + 12 + r   quad r = 12dots  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon can be considered as a \"scaling parameter\", it allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it can be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Bessel potential space H^s_varepsilon (R^n) is a Reproducing kernel Hilbert space, an element f of that space can be treated as a bounded r-times continuously differentiable function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method consists in finding a solution of system (1) having minimal norm in Hilbert space H^s_varepsilon (R^n)  thus an interpolating normal spline sigma is defined as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag2\r\n   sigma = rm argmin   f ^2  (1) forall f in H^s_varepsilon (R^n)   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method is based on the following functional analysis results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bessel potential space embedding theorem\nThe Riesz representation theorem for Hilbert spaces\nReproducing kernel properties","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using these results it is possible to reduce the task (2) to solving a system of linear equations with symmetric positive definite Gram matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method for one-dimensional function interpolation and linear ordinary differential and integral equations was proposed in [1]. Multivariate generalization of the normal splines method was developed for two-dimensional problem of low-range computerized tomography in [2] and applied for solving a mathematical economics problem in [3]. Further results were reported at the seminars and conferences [4,5,6].","category":"page"},{"location":"#References:","page":"Home","title":"References:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] V. Gorbunov, The method of normal spline collocation. USSR Comput.Maths.Math.Phys., Vol. 29, No. 1, 1989","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] I. Kohanovsky, Normal Splines in Computing Tomography (in Russian). Avtometriya, No.2, 1995","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] V. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] I. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar on Approximation of Multiparametric functions, Max-Planck-Institute for Mathematics in the Sciences, Leipzig, Germany, 2011.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6] V. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, University of West Bohemia, Plzen, Czech Republic, 2014.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\r\n      \"index.md\",\r\n      \"Public-API.md\",\r\n      \"Usage.md\",\r\n]\r\nDepth = 3","category":"page"},{"location":"Public-API/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"Public-API/#API-Summary","page":"Public API","title":"API Summary","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Function Description\nprepare Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem.\nconstruct Construct the spline by calculating its coefficients.\ninterpolate Prepare and construct the spline.\nevaluate Evaluate the spline value at the required locations\nevaluate_one Evaluate the spline value at the required location\nevaluate_gradient Evaluate gradient of the spline at the required location.\nevaluate_derivative Evaluate the 1D spline derivative at the required location.\nestimate_accuracy Estimate accuracy of the function interpolation result.\nestimate_cond Estimate the Gram matrix 1-norm condition number.\nestimate_epsilon Estimate the 'scaling parameter' of Bessel potential space the spline being built in.\nget_epsilon Get the 'scaling parameter' of Bessel potential space the normal spline was built in.\nget_cond Get the Gram matrix spectral condition number.","category":"page"},{"location":"Public-API/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"prepare\r\nconstruct\r\ninterpolate\r\nevaluate\r\nevaluate_one\r\nevaluate_gradient\r\nevaluate_derivative\r\nestimate_accuracy\r\nestimate_cond\r\nget_epsilon\r\nestimate_epsilon\r\nget_cond","category":"page"},{"location":"Public-API/#NormalHermiteSplines.prepare","page":"Public API","title":"NormalHermiteSplines.prepare","text":"prepare(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes.           It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes.            This should be an n×n_2 matrix, where n is dimension of the sampled space and            n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.       This should be an n×n_2 matrix, where n is dimension of the sampled space and       n_2 is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the 1D normal spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivatives nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.construct","page":"Public API","title":"NormalHermiteSplines.construct","text":"construct(spline::NormalSpline{T, RK}, values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\nconstruct(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\nd_values: function directional derivative values at d_nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.interpolate","page":"Public API","title":"NormalHermiteSplines.interpolate","text":"interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nd_nodes: The function directional derivative nodes.           This should be an n×n_2 matrix, where n is dimension of the sampled space and           n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.      This should be an n×n_2 matrix, where n is dimension of the sampled space and      n_2 is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.\nd_values: function directional derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at n_1 interpolation nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, d_nodes::Vector{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: The function value nodes.\nvalues: function values at nodes nodes.\nd_nodes: The function derivative nodes.\nd_values: function derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate","page":"Public API","title":"NormalHermiteSplines.evaluate","text":"evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values at the locations defined in points.\n\nArguments\n\nspline: theNormalSplineobject returned byinterpolateorconstruct` function.\npoints: locations at which spline values are evaluating.           This should be an n×m matrix, where n is dimension of the sampled space           and m is the number of locations where spline values are evaluating.           It means that each column in the matrix defines one location.\n\nReturn: Vector{T} of the spline values at the locations defined in points.\n\n\n\n\n\nevaluate(spline::NormalSpline{T, RK}, points::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values/value at the points locations.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoints: locations at which spline values are evaluating.                      This should be a vector of size m where m is the number of evaluating points.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_one","page":"Public API","title":"NormalHermiteSplines.evaluate_one","text":"evaluate_one(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nReturn: the spline value at the location defined in point.\n\n\n\n\n\nevaluate_one(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_gradient","page":"Public API","title":"NormalHermiteSplines.evaluate_gradient","text":"evaluate_gradient(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate gradient of the spline at the location defined in point.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which gradient value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nNote: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturn: Vector{T} - gradient of the spline at the location defined in point.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_derivative","page":"Public API","title":"NormalHermiteSplines.evaluate_derivative","text":"evaluate_derivative(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline derivative at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline derivative is evaluating.\n\nNote: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.\n\nReturn: the spline derivative value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_accuracy","page":"Public API","title":"NormalHermiteSplines.estimate_accuracy","text":"estimate_accuracy(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nAssess accuracy of interpolation results by analyzing residuals.\n\nArguments\n\nspline: the NormalSpline object returned by construct or interpolate function.\n\nReturn: an estimation of the number of significant digits in the interpolation result.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_cond","page":"Public API","title":"NormalHermiteSplines.estimate_cond","text":"estimate_cond(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet an estimation of the Gram matrix condition number. It needs the spline object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: an estimation of the Gram matrix condition number.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_epsilon","page":"Public API","title":"NormalHermiteSplines.get_epsilon","text":"get_epsilon(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet the 'scaling parameter' of Bessel Potential space the spline was built in.\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: ε - the 'scaling parameter'.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_epsilon","page":"Public API","title":"NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in.          It must be a struct object of the following type:            RK_H0 if the spline is constructing as a continuous function,            RK_H1 if the spline is constructing as a differentiable function,            RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nd_nodes: The function directional derivative nodes.          This should be an n×n_2 matrix, where n is dimension of the sampled space and          n_2 is the number of function directional derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline will be constructed in.           It must be a struct object of the following type:           RK_H1 if the spline is constructing as a differentiable function,           RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline being built in. It coincides with the result returned by get_epsilon function.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivative nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: estimation of ε.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_cond","page":"Public API","title":"NormalHermiteSplines.get_cond","text":"get_cond(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: a value of the Gram matrix spectral condition number.\n\n\n\n\n\nget_cond(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nGet a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires O(N^3) operations.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes.           It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes.            This should be an n×n_2 matrix, where n is dimension of the sampled space and            n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.       This should be an n×n_2 matrix, where n is dimension of the sampled space and       n_2 is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: a value of the Gram matrix spectral condition number.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"Public-API/#Bessel-potential-Space-Reproducing-Kernels","page":"Public API","title":"Bessel potential Space Reproducing Kernels","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"RK_H0\r\nRK_H1\r\nRK_H2","category":"page"},{"location":"Public-API/#NormalHermiteSplines.RK_H0","page":"Public API","title":"NormalHermiteSplines.RK_H0","text":"struct RK_H0{T <: AbstractFloat} <: ReproducingKernel_0\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 12_ε (R^n) ('Basic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H1","page":"Public API","title":"NormalHermiteSplines.RK_H1","text":"struct RK_H1{T <: AbstractFloat} <: ReproducingKernel_1\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 32_ε (R^n) ('Linear Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (1 + varepsilon xi  - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H2","page":"Public API","title":"NormalHermiteSplines.RK_H2","text":"struct RK_H2{T <: AbstractFloat} <: ReproducingKernel_2\n\nDefines a type of reproducing kernel of Bessel Potential space H^n2 + 52_ε (R^n) ('Quadratic Matérn kernel'):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (3 + 3varepsilon xi  - eta + varepsilon ^2 xi - eta ^2 )  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalSpline-structure","page":"Public API","title":"NormalSpline structure","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"NormalSpline","category":"page"},{"location":"Public-API/#NormalHermiteSplines.NormalSpline","page":"Public API","title":"NormalHermiteSplines.NormalSpline","text":"struct NormalSpline{T, RK} <: AbstractSpline where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nDefine a structure containing full information of a normal spline\n\nFields\n\n_kernel: a reproducing kernel spline was built with\n_compression: factor of transforming the original node locations into unit hypercube\n_nodes: transformed function value nodes\n_values: function values at interpolation nodes\n_d_nodes: transformed function directional derivative nodes\n_es: normalized derivative directions\n_d_values: function directional derivative values\n_min_bound: minimal bounds of the original node locations area\n_gram: Gram matrix of the problem\n_chol: Cholesky factorization of the Gram matrix\n_mu: spline coefficients\n_cond: estimation of the Gram matrix condition number\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Order = [:function, :type]","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · NormalHermiteSplines.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NormalHermiteSplines.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#API-Summary"><span>API Summary</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Usage/">Example Usage</a></li><li><a class="tocitem" href="../Normal-Splines-Method/">Normal Splines Method</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/master/docs/src/Public-API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="API-Summary"><a class="docs-heading-anchor" href="#API-Summary">API Summary</a><a id="API-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#API-Summary" title="Permalink"></a></h2><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>prepare</code></td><td style="text-align: left">Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem.</td></tr><tr><td style="text-align: left"><code>construct</code></td><td style="text-align: left">Construct the spline by calculating its coefficients.</td></tr><tr><td style="text-align: left"><code>interpolate</code></td><td style="text-align: left">Prepare and construct the spline.</td></tr><tr><td style="text-align: left"><code>evaluate</code></td><td style="text-align: left">Evaluate the spline value at the required locations</td></tr><tr><td style="text-align: left"><code>evaluate_one</code></td><td style="text-align: left">Evaluate the spline value at the required location</td></tr><tr><td style="text-align: left"><code>evaluate_gradient</code></td><td style="text-align: left">Evaluate gradient of the spline at the required location.</td></tr><tr><td style="text-align: left"><code>evaluate_derivative</code></td><td style="text-align: left">Evaluate the 1D spline derivative at the required location.</td></tr><tr><td style="text-align: left"><code>estimate_accuracy</code></td><td style="text-align: left">Estimate accuracy of the function interpolation result.</td></tr><tr><td style="text-align: left"><code>estimate_cond</code></td><td style="text-align: left">Estimate the Gram matrix 1-norm condition number.</td></tr><tr><td style="text-align: left"><code>estimate_epsilon</code></td><td style="text-align: left">Estimate the &#39;scaling parameter&#39; of Bessel potential space the spline being built in.</td></tr><tr><td style="text-align: left"><code>get_epsilon</code></td><td style="text-align: left">Get the &#39;scaling parameter&#39; of Bessel potential space the normal spline was built in.</td></tr><tr><td style="text-align: left"><code>get_cond</code></td><td style="text-align: left">Get the Gram matrix spectral condition number.</td></tr></table><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.prepare" href="#NormalHermiteSplines.prepare"><code>NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prepare(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L63-L80">source</a></section><section><div><p><code>prepare(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes.           It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivatives nodes.            This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and            <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.       This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_2</code> is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L193-L217">source</a></section><section><div><p><code>prepare(nodes::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L380-L395">source</a></section><section><div><p><code>prepare(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare the 1D normal spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>d_nodes</code>: The function derivatives nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L488-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.construct" href="#NormalHermiteSplines.construct"><code>NormalHermiteSplines.construct</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>construct(spline::NormalSpline{T, RK}, values::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Construct the spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L88-L98">source</a></section><section><div><p><code>construct(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Construct the spline by calculating its coefficients and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_values</code>: function directional derivative values at <code>d_nodes</code> nodes.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L227-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.interpolate" href="#NormalHermiteSplines.interpolate"><code>NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L106-L123">source</a></section><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare and construct the spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_nodes</code>: The function directional derivative nodes.           This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and           <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.      This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and      <code>n_2</code> is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>d_values</code>: function directional derivative values at <code>d_nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L247-L271">source</a></section><section><div><p><code>interpolate(nodes::Vector{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare and construct the 1D spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values</code>: function values at <code>n_1</code> interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L403-L420">source</a></section><section><div><p><code>interpolate(nodes::Vector{T}, values::Vector{T}, d_nodes::Vector{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare and construct the 1D spline.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>values</code>: function values at <code>nodes</code> nodes.</li><li><code>d_nodes</code>: The function derivative nodes.</li><li><code>d_values</code>: function derivative values at <code>d_nodes</code> nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: the completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L514-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate" href="#NormalHermiteSplines.evaluate"><code>NormalHermiteSplines.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline values at the locations defined in <code>points</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline: the</code>NormalSpline<code>object returned by</code>interpolate<code>or</code>construct` function.</li><li><code>points</code>: locations at which spline values are evaluating.           This should be an <code>n×m</code> matrix, where <code>n</code> is dimension of the sampled space           and <code>m</code> is the number of locations where spline values are evaluating.           It means that each column in the matrix defines one location.</li></ul><p>Return: <code>Vector{T}</code> of the spline values at the locations defined in <code>points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L133-L146">source</a></section><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, points::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline values/value at the <code>points</code> locations.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>points</code>: locations at which spline values are evaluating.                      This should be a vector of size <code>m</code> where <code>m</code> is the number of evaluating points.</li></ul><p>Return: spline value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L430-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate_one" href="#NormalHermiteSplines.evaluate_one"><code>NormalHermiteSplines.evaluate_one</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_one(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline value is evaluating.          This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Return: the spline value at the location defined in <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L153-L164">source</a></section><section><div><p><code>evaluate_one(spline::NormalSpline{T, RK}, point::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline value at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline value is evaluating.</li></ul><p>Return: spline value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L448-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate_gradient" href="#NormalHermiteSplines.evaluate_gradient"><code>NormalHermiteSplines.evaluate_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_gradient(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate gradient of the spline at the location defined in <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which gradient value is evaluating.          This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Note: Gradient of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p>Return: <code>Vector{T}</code> - gradient of the spline at the location defined in <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate_derivative" href="#NormalHermiteSplines.evaluate_derivative"><code>NormalHermiteSplines.evaluate_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_derivative(spline::NormalSpline{T, RK}, point::T) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate the 1D spline derivative at the <code>point</code> location.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point</code>: location at which spline derivative is evaluating.</li></ul><p>Note: Derivative of spline built with reproducing kernel RK_H0 does not exist at the spline nodes.</p><p>Return: the spline derivative value at the <code>point</code> location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L467-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.estimate_accuracy" href="#NormalHermiteSplines.estimate_accuracy"><code>NormalHermiteSplines.estimate_accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_accuracy(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Assess accuracy of interpolation results by analyzing residuals.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: an estimation of the number of significant digits in the interpolation result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L365-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.estimate_cond" href="#NormalHermiteSplines.estimate_cond"><code>NormalHermiteSplines.estimate_cond</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_cond(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get an estimation of the Gram matrix condition number. It needs the <code>spline</code> object is prepared and requires O(N^2) operations. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: an estimation of the Gram matrix condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L350-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.get_epsilon" href="#NormalHermiteSplines.get_epsilon"><code>NormalHermiteSplines.get_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_epsilon(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get the &#39;scaling parameter&#39; of Bessel Potential space the spline was built in.</p><p><strong>Arguments</strong></p><ul><li><code>spline</code>: the <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: <code>ε</code> - the &#39;scaling parameter&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L284-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.estimate_epsilon" href="#NormalHermiteSplines.estimate_epsilon"><code>NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_epsilon(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in.          It must be a struct object of the following type:            <code>RK_H0</code> if the spline is constructing as a continuous function,            <code>RK_H1</code> if the spline is constructing as a differentiable function,            <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L298-L314">source</a></section><section><div><p><code>estimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivative nodes.          This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline will be constructed in.           It must be a struct object of the following type:           <code>RK_H1</code> if the spline is constructing as a differentiable function,           <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L322-L341">source</a></section><section><div><p><code>estimate_epsilon(nodes::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L542-L556">source</a></section><section><div><p><code>estimate_epsilon(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the spline being built in. It coincides with the result returned by <code>get_epsilon</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.</li><li><code>d_nodes</code>: The function derivative nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L564-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.get_cond" href="#NormalHermiteSplines.get_cond"><code>NormalHermiteSplines.get_cond</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_cond(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires <span>$O(N^3)$</span> operations.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a value of the Gram matrix spectral condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L587-L602">source</a></section><section><div><p><code>get_cond(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Get a value of the Gram matrix spectral condition number. It is obtained by means of the matrix SVD decomposition and requires <span>$O(N^3)$</span> operations.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: The function value nodes.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes.           It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: The function directional derivatives nodes.            This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and            <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.       This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_2</code> is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a value of the Gram matrix spectral condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L607-L629">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Bessel-potential-Space-Reproducing-Kernels"><a class="docs-heading-anchor" href="#Bessel-potential-Space-Reproducing-Kernels">Bessel potential Space Reproducing Kernels</a><a id="Bessel-potential-Space-Reproducing-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Bessel-potential-Space-Reproducing-Kernels" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H0" href="#NormalHermiteSplines.RK_H0"><code>NormalHermiteSplines.RK_H0</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H0{T &lt;: AbstractFloat} &lt;: ReproducingKernel_0</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 1/2}_ε (R^n)$</span> (&#39;Basic Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/ReproducingKernels.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H1" href="#NormalHermiteSplines.RK_H1"><code>NormalHermiteSplines.RK_H1</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H1{T &lt;: AbstractFloat} &lt;: ReproducingKernel_1</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 3/2}_ε (R^n)$</span> (&#39;Linear Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (1 + \varepsilon |\xi  - \eta|) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/ReproducingKernels.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H2" href="#NormalHermiteSplines.RK_H2"><code>NormalHermiteSplines.RK_H2</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H2{T &lt;: AbstractFloat} &lt;: ReproducingKernel_2</code></p><p>Defines a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 5/2}_ε (R^n)$</span> (&#39;Quadratic Matérn kernel&#39;):</p><p class="math-container">\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (3 + 3\varepsilon |\xi  - \eta| + \varepsilon ^2 |\xi - \eta| ^2 ) \, .\]</p><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/ReproducingKernels.jl#L58-L70">source</a></section></article><h3 id="NormalSpline-structure"><a class="docs-heading-anchor" href="#NormalSpline-structure">NormalSpline structure</a><a id="NormalSpline-structure-1"></a><a class="docs-heading-anchor-permalink" href="#NormalSpline-structure" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.NormalSpline" href="#NormalHermiteSplines.NormalSpline"><code>NormalHermiteSplines.NormalSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct NormalSpline{T, RK} &lt;: AbstractSpline where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Define a structure containing full information of a normal spline</p><p><strong>Fields</strong></p><ul><li><code>_kernel</code>: a reproducing kernel spline was built with</li><li><code>_compression</code>: factor of transforming the original node locations into unit hypercube</li><li><code>_nodes</code>: transformed function value nodes</li><li><code>_values</code>: function values at interpolation nodes</li><li><code>_d_nodes</code>: transformed function directional derivative nodes</li><li><code>_es</code>: normalized derivative directions</li><li><code>_d_values</code>: function directional derivative values</li><li><code>_min_bound</code>: minimal bounds of the original node locations area</li><li><code>_gram</code>: Gram matrix of the problem</li><li><code>_chol</code>: Cholesky factorization of the Gram matrix</li><li><code>_mu</code>: spline coefficients</li><li><code>_cond</code>: estimation of the Gram matrix condition number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/283617995db41bb9d6ea0f53b42b1a8aaabcb50e/src/NormalHermiteSplines.jl#L25-L43">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NormalHermiteSplines.construct"><code>NormalHermiteSplines.construct</code></a></li><li><a href="#NormalHermiteSplines.estimate_accuracy"><code>NormalHermiteSplines.estimate_accuracy</code></a></li><li><a href="#NormalHermiteSplines.estimate_cond"><code>NormalHermiteSplines.estimate_cond</code></a></li><li><a href="#NormalHermiteSplines.estimate_epsilon"><code>NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#NormalHermiteSplines.evaluate"><code>NormalHermiteSplines.evaluate</code></a></li><li><a href="#NormalHermiteSplines.evaluate_derivative"><code>NormalHermiteSplines.evaluate_derivative</code></a></li><li><a href="#NormalHermiteSplines.evaluate_gradient"><code>NormalHermiteSplines.evaluate_gradient</code></a></li><li><a href="#NormalHermiteSplines.evaluate_one"><code>NormalHermiteSplines.evaluate_one</code></a></li><li><a href="#NormalHermiteSplines.get_cond"><code>NormalHermiteSplines.get_cond</code></a></li><li><a href="#NormalHermiteSplines.get_epsilon"><code>NormalHermiteSplines.get_epsilon</code></a></li><li><a href="#NormalHermiteSplines.interpolate"><code>NormalHermiteSplines.interpolate</code></a></li><li><a href="#NormalHermiteSplines.prepare"><code>NormalHermiteSplines.prepare</code></a></li><li><a href="#NormalHermiteSplines.NormalSpline"><code>NormalHermiteSplines.NormalSpline</code></a></li><li><a href="#NormalHermiteSplines.RK_H0"><code>NormalHermiteSplines.RK_H0</code></a></li><li><a href="#NormalHermiteSplines.RK_H1"><code>NormalHermiteSplines.RK_H1</code></a></li><li><a href="#NormalHermiteSplines.RK_H2"><code>NormalHermiteSplines.RK_H2</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Usage/">Example Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 April 2021 10:48">Monday 12 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
